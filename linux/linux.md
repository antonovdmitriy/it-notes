# Содержание
- [Содержание](#содержание)
- [Полезности bash shell](#полезности-bash-shell)
  - [TAB - заполнение](#tab---заполнение)
  - [История](#история)
  - [Режим поиск Ctrl + R](#режим-поиск-ctrl--r)
  - [SSH (Secure Shell)](#ssh-secure-shell)
  - [Virtual terminals](#virtual-terminals)
  - [Относительный путь и ссылки на директории](#относительный-путь-и-ссылки-на-директории)
  - [Piping](#piping)
  - [I/O Redirection](#io-redirection)
  - [Использование regexp (globing)](#использование-regexp-globing)
    - [Расширенный globing](#расширенный-globing)
  - [Alias](#alias)
- [Вывод в stdout](#вывод-в-stdout)
  - [echo](#echo)
  - [printf](#printf)
- [Нагрузка системы](#нагрузка-системы)
- [Создать файл определенного размера](#создать-файл-определенного-размера)
- [Операции с файлами и каталогами](#операции-с-файлами-и-каталогами)
    - [Изменить текущий каталог](#изменить-текущий-каталог)
    - [Переместить файл](#переместить-файл)
    - [Создать пустой файл](#создать-пустой-файл)
    - [Название текущей директории](#название-текущей-директории)
    - [Создать директорию](#создать-директорию)
    - [Удаление файлов и каталогов](#удаление-файлов-и-каталогов)
    - [Копирование файлов и каталогов](#копирование-файлов-и-каталогов)
    - [Удаление файлов и каталогов](#удаление-файлов-и-каталогов-1)
    - [Тип файла](#тип-файла)
    - [Расположение запускаемой команды](#расположение-запускаемой-команды)
    - [Просмотре дерева каталогов](#просмотре-дерева-каталогов)
      - [Опции](#опции)
    - [cat](#cat)
      - [Опции](#опции-1)
    - [more](#more)
    - [type](#type)
  - [zless](#zless)
- [Команды помощи](#команды-помощи)
- [Фильтры](#фильтры)
  - [wc (Word count)](#wc-word-count)
    - [Опции](#опции-2)
  - [head Показать первые n строк.](#headпоказать-первые-n-строк)
  - [tail Показать последние n строк.](#tail-показать-последние-n-строк)
  - [tr(translate)](#trtranslate)
  - [cut  (выбрать значение из колонки)](#cut-выбрать-значение-из-колонки)
  - [sort (сортировка)](#sort-сортировка)
    - [Опции](#опции-3)
  - [grep](#grep)
    - [Поиск в файлах и директориях](#поиск-в-файлах-и-директориях)
  - [sed (stream editor)](#sed-stream-editor)
    - [sed как отображатель конкретных строк из файла](#sed-как-отображатель-конкретных-строк-из-файла)
    - [sed как удалитель строк в файлах или потоках](#sed-как-удалитель-строк-в-файлах-или-потоках)
    - [sed как редактор поток и файлов](#sed-как-редактор-поток-и-файлов)
    - [sed как редактор многих файлов за одну команду](#sed-как-редактор-многих-файлов-за-одну-команду)
  - [awk](#awk)
  - [Интересные примеры использования комбинаций команд](#интересные-примеры-использования-комбинаций-команд)
  - [less](#less)
    - [Поиск](#поиск)
    - [Навигация](#навигация)
- [Мониторинг системы](#мониторинг-системы)
    - [Top](#top)
      - [Полезные клавиши top:](#полезные-клавиши-top)
- [Партиционирование и монтирование](#партиционирование-и-монтирование)
  - [Файловые системы](#файловые-системы)
    - [XFS](#xfs)
    - [Ex4.](#ex4)
  - [XFS бекапы](#xfs-бекапы)
  - [Партиции](#партиции)
    - [Загрузчики](#загрузчики)
  - [Отличия MBR и GPT](#отличия-mbr-и-gpt)
    - [MBR](#mbr)
    - [GPT](#gpt)
    - [lsbsk](#lsbsk)
  - [Список партиций](#список-партиций)
  - [Parted (утилита для работы с партициями)](#parted-утилита-для-работы-с-партициями)
    - [Команды parted](#команды-parted)
      - [Опции:](#опции-4)
      - [Пример использования parted](#пример-использования-parted)
  - [fdisk (утилита для MBR партиций)](#fdisk-утилита-для-mbr-партиций)
  - [Утилиты для создания файловых систем (форматирования)](#утилиты-для-создания-файловых-систем-форматирования)
  - [Mount партиций](#mount-партиций)
    - [Временный mount](#временный-mount)
    - [Постоянный mount через fstab](#постоянный-mount-через-fstab)
    - [mount через systemd mount](#mount-через-systemd-mount)
    - [Automount](#automount)
      - [Пример настройки динамического home](#пример-настройки-динамического-home)
  - [Именование устройств (UUID, Label)](#именование-устройств-uuid-label)
  - [SWAP партиции](#swap-партиции)
  - [LVM Logical volumes](#lvm-logical-volumes)
    - [Physical volume, logical group, logical volume. Создание](#physical-volume-logical-group-logical-volume-создание)
    - [Изменение размера logical volume](#изменение-размера-logical-volume)
  - [Stratis](#stratis)
    - [Изменение размера stratis volume](#изменение-размера-stratis-volume)
    - [Снепшоты](#снепшоты)
  - [VDO-виртуальный оптимизатор данных](#vdo-виртуальный-оптимизатор-данных)
  - [LUKS encrypted volume](#luks-encrypted-volume)
- [Переменные окружения](#переменные-окружения)
  - [Переменные сессии](#переменные-сессии)
  - [Установка с сохранением после перезапуска](#установка-с-сохранением-после-перезапуска)
    - [для всех пользователей](#для-всех-пользователей)
    - [для конкретного пользователя](#для-конкретного-пользователя)
  - [Разница profile и bashrc](#разница-profile-и-bashrc)
- [Vim](#vim)
  - [Команды выхода](#команды-выхода)
  - [Исправления действий](#исправления-действий)
  - [Навигация](#навигация-1)
  - [Команды редактирования](#команды-редактирования)
  - [Режим выделения](#режим-выделения)
  - [Разное](#разное)
  - [Поиск](#поиск-1)
  - [Замена](#замена)
- [Ссылки Links](#ссылки-links)
- [Операции с архивами](#операции-с-архивами)
  - [tar](#tar)
    - [Опции tar:](#опции-tar)
    - [Запаковать директорию](#запаковать-директорию)
    - [Распаковать директорию](#распаковать-директорию)
  - [gzip](#gzip)
- [Структура каталогов FHS](#структура-каталогов-fhs)
- [Поиск](#поиск-2)
  - [find Поиск файлов в директории](#findпоиск-файлов-в-директории)
  - [locate](#locate)
- [Cockpit](#cockpit)
  - [Установка](#установка)
  - [Запуск и проверка](#запуск-и-проверка)
- [Midnight Comander](#midnight-comander)
  - [Избранные директории в mc](#избранные-директории-в-mc)
  - [Цветовая схема](#цветовая-схема)
  - [Открывать файлы через приложения windows](#открывать-файлы-через-приложения-windows)
- [Разные команды](#разные-команды)
  - [comm (сравнение файлов)](#comm-сравнение-файлов)
    - [Отобразить только одну колонку](#отобразить-только-одну-колонку)
  - [tee. Запись в файл с возможность перенаправить stdout дальше](#tee-запись-в-файл-с-возможность-перенаправить-stdout-дальше)
  - [uniq](#uniq)
  - [Команды для работы со временем](#команды-для-работы-со-временем)
- [Open SUSE](#open-suse)
- [Запуск процессов по расписанию](#запуск-процессов-по-расписанию)
- [Cron](#cron)
  - [at](#at)
- [Временные файлы systemd-tmpfiles](#временные-файлы-systemd-tmpfiles)
- [Virtual Box](#virtual-box)
  - [mnt дисков](#mnt-дисков)
  - [Настройка сети](#настройка-сети)
  - [CentoOS VirtualBoxGuest](#centoos-virtualboxguest)
  - [Расширения дискового пространтсва](#расширения-дискового-пространтсва)
- [VM Ware](#vm-ware)
  - [mount](#mount)
- [Операции с пользователями](#операции-с-пользователями)
- [Операции с правами](#операции-с-правами)
  - [File Permission](#file-permission)
  - [umask](#umask)
  - [Специальные права доступа](#специальные-права-доступа)
  - [ACL (Access Control List)](#acl-access-control-list)
  - [Примеры сложностей понимания прав доступа](#примеры-сложностей-понимания-прав-доступа)
    - [Удаление файла](#удаление-файла)
    - [Запись в файл](#запись-в-файл)
    - [Смена прав доступа](#смена-прав-доступа)
- [Свойства пользователя](#свойства-пользователя)
  - [Операции с группами](#операции-с-группами)
- [Сеть](#сеть)
  - [NMCLI (Network Manager command line interface)](#nmcli-network-manager-command-line-interface)
    - [Создание новой конфигурации подключения](#создание-новой-конфигурации-подключения)
  - [nmtui (Network Manager text user interface)](#nmtui-network-manager-text-user-interface)
  - [Расположение файлов конфигураций сетевых интфейсов](#расположение-файлов-конфигураций-сетевых-интфейсов)
  - [Проверка сетевого соединения](#проверка-сетевого-соединения)
- [Управление процессами](#управление-процессами)
  - [Сигналы](#сигналы)
  - [Приоритеты](#приоритеты)
  - [Профилирование системы](#профилирование-системы)
- [Установка пакетов RPM(Red Hat Package Manager)](#установка-пакетов-rpmred-hat-package-manager)
  - [Пакеты](#пакеты)
  - [Модули](#модули)
  - [Группы](#группы)
  - [История изменений](#история-изменений)
- [Systemd](#systemd)
  - [Конфигурация юнитов](#конфигурация-юнитов)
    - [пример модификации конфигурации](#пример-модификации-конфигурации)
- [Логирование](#логирование)
  - [Rsyslogd](#rsyslogd)
  - [systemd-journald](#systemd-journald)
  - [logrotate](#logrotate)
  - [/proc и ядро](#proc-и-ядро)
  - [Загрузка (boot)](#загрузка-boot)
  - [systemd target](#systemd-target)
  - [Проблемы при загрузке](#проблемы-при-загрузке)
    - [Восстановление пароля root.](#восстановление-пароля-root)
    - [Проблемы при mount во время старта](#проблемы-при-mount-во-время-старта)
- [Bash Shell scripts](#bash-shell-scripts)
  - [Основные конструкции](#основные-конструкции)
    - [swich](#swich)
- [SSH](#ssh)
  - [Копирование файлов по сети](#копирование-файлов-по-сети)
    - [scp](#scp)
    - [sftp](#sftp)
  - [Rsync Синхронизация директорий по сети](#rsync-синхронизация-директорий-по-сети)
    - [опции:](#опции-5)
- [HTTP Server](#http-server)
- [SELinux](#selinux)
  - [Context label](#context-label)
  - [Boolean](#boolean)
  - [Изменение context label](#изменение-context-label)
  - [Чтение лога SELinux](#чтение-лога-selinux)
- [Firewalling](#firewalling)
- [Linux time](#linux-time)
- [Kickstart](#kickstart)
- [Vagrant](#vagrant)
- [Подключение сетевых дисков](#подключение-сетевых-дисков)
  - [NFS](#nfs)
  - [Samba](#samba)
- [Проброс X11](#проброс-x11)
    - [на сервере:](#на-сервере)
    - [На клиенте:](#на-клиенте)

# Полезности bash shell
## TAB - заполнение
При вводе команды, если нажать на двойной TAB выведется все команды начинающиеся на уже введенные символы.

![](images/image154.png)

## История
`history` отображение ранее выполненных команд

![](images/image417.png)

Повторить команду из истории `!номер_команды` например `!25`

Также еще опасный способ повторить из истории !f команду начинающуюся на f

## Режим поиск Ctrl + R
При входе в этот режим, подходящие команды найдутся в истории по нескольким символам

![](images/image430.png)

## SSH (Secure Shell)
Подключиться на удаленный сервер под пользователем `ssh user_name@host`
```bash
    ssh dima@192.168.100.9
```

Можно подключиться даже из Git Bash и из CMD и из PowerShell, если ssh доступен в windows

## Virtual terminals
Если напрямую находимся в графическом интерфейсе, можно переключить виртуальные терминалы. Обычно 1 и 2 это графические терминалы, остальные консольные. Переключаться можно через Ctrl + Alt + номер_терминала. Либо через команду из под root `сhvt номер_терминала`

## Относительный путь и ссылки на директории

`.` текущая директория

`..` директория выше на уровень

`../../` директория выше на два уровня  

`~` директория пользователя  

`/` корень файловой системы

Linux допускает пробелы в названиях файлов. Но передачи пути необходимо в этом случае заключать это имя в кавычки ``‘’`` или писать `\` после первого слова

Скрытые файла начинаются с `.`  Если убрать точку, файл перестает быть скрытым

## Piping

Перенаправление результатов предыдущей команды в аргументы последующей. Точнее stdout поток первой в stdin поток второй команды.
```bash
ls -l | less
```

Выводим список процессов и перенаправляем в редактор less для удобного скролинга
```bash
ps aux | less    
```

Список директорий и размер их. Далее сортируем по числам (n) и инвертируем список ( от большего к меньшему)
```bash
du | sort -nr 
```

## I/O Redirection

Перенаправление stdout в новый файл
```bash
ls > file_list.txt 
```

Не создаем новый файл, если уже  существует
```bash
ls >> file_list.txt 
```

Берем аргументы из файлы
```bash
sort < file_list.txt 
```

Можно перенаправлять поток ошибок (stderr), иногда полезно чтобы ошибки не отображались вовсе, тогда перенаправляем в стандартное место для этого
```bash
ls . sdfsdfsdf 2> /dev/null
```

Чтобы и stdout и stderr направлялись в один файл
```bash
ls -l /bin/usr > ls-output.txt 2>&1
```

И еще вариант того же  
```bash
ls -l /bin/usr &> ls-output.txt  
ls -l /bin/usr &>> ls-output.txt
```

## Использование regexp (globing)

Многие команды позволяют использовать аргументы с patterns. Если не понятно что это, почитайте про regexp. 

`*` - ноль или много символов

`?` - один символ

`[..]` - один символ из перечисленных

Примеры:
```bash
ls host*

ls ?ost*

ls [mh]ost

ls [!mh]ost

ls host[0-9][0-9]
```
### Расширенный globing

можно включить опцию баша, при которой начнет работать расширенные паттерны
```bash
shopt -s extglob
```
`?(pattern)` - ноль или одно нахождение паттерна

`*(pattern)` - ноль или много нахождений паттерна

`+(pattern)` - один или более нахождений паттерна

`@(pattern)` - строго одно нахождение паттерна


```bash
shopt +s extglob
touch .txt e.txt ee.txt eee.txt
ls *.txt
ls ?(e).txt
ls *(e).txt
ls +(e).txt
ls @(e).txt
```
![](images/ext_globing_1.png)

## Alias

Используется для короткой формы команд.

Показывает список команд ссылок на другие команды
```bash
alias 
```
![](images/image327.png)

создать новый  
```bash
alias h=history
```

удалить 
```bash
unalias h
```
# Вывод в stdout 

## echo
`echo some_text`    Напечатать текст
```bash
echo some_text
```
Опция `-e` позволяет писать дальше в кавычках управляющие символы. Без этой опции они будут выводиться как обычные буквы
```bash
echo -e "some \n texts"
```
управляющие символы: 
- `\b` backspace 
- `\n` newline 
- `\t` tab

## printf
Пример:
```bash
printf "%s\n" "hello world"
```
если написать без кавычек фразу
```bash
printf "%s\n" hello world # будет перенос строки после первого слова
```

а если оба с кавычками также с переносом
```bash
printf "%s\n" "hello" "world"
```
![printf examples](images/printf_1.png)

символы: 
- `%s` строка 
- `%d` целое числов 
- `%f` дробное число. Для дробных можно указывать точность вот так например с одним разрядок в дробной части

```bash
printf "%.1f\n" 255
```
также printf может переводить из других систем счисления, но работает только с целыми числами. Если использовать f может быть разная интерпретация
![printf examples](images/printf_2.png)


# Нагрузка системы
нагрузить процессор. Копировать ничто в никуда
```bash
dd if=/dev/zero of=/dev/null 
```

# Создать файл определенного размера

создаем файл `bitfile` в текущей директории размеров 508 мегабайт
```bash
dd=if=/dev/zero of=bigfile bs=1M count=508
```

# Операции с файлами и каталогами

### Изменить текущий каталог
`cd path` изменить текущий каталог
### Переместить файл
`mv filename1 filename2` Переместить файл. 
Удобно использовать паттерны:
```bash
mv script* new_directory/
```
### Создать пустой файл
`touch path`    Создать пустой файл.
можно создать много пустых файлов
```bash
touch myfile{0..10}
```
### Название текущей директории
`pwd` текущая директория

### Создать директорию
`mkdir dirname ...` Создать директории или несколько директорий
![Linux mkdir command 2](images/image386.png)

можно также создавать и подкаталоги сразу же 
```bash
mkdir -p new/new/new
```
Опция `-v` - печатать то, что делается командой

Если директория уже создана, то будет показываться ошибка. За исключением случаев, когда создаем my/my1/../myn  Ошибки не будет, если часть дерева уже есть.

### Удаление файлов и каталогов

`rmdir path` Удаляет **ТОЛЬКО ПУСТЫЕ** директории.

`-p` удалять родительские директории, если это необходимо

`-v` печатать то, что делается

### Копирование файлов и каталогов
`cp source destination` копировать файл

Можно использовать паттерны. Например: Скопировать все файлы из директории в текущую.
```bash
cp /etc/h* . 
``` 

 Если необходимо скопировать файлы в том числе из вложенных директорий
```bash
cp -r /etc/h* .
```

### Удаление файлов и каталогов
`rm` Команда удаления. 
Поддерживает паттерны 
```bash
rm *extenstion
```
Удаляет директорию scripts и все файлы в ней. `-f` опция для отключения предупреждений.
```bash
rm -rf ./scripts
```
 Также есть опция `-v`, для отображения что удаляем `-i` для подтверждения удаления

### Тип файла
`file  location` посмотреть тип файла. 

Поддерживает паттерны 
```bash
file *
```

### Расположение запускаемой команды

`which` Показывает расположение команды. Работает только с запускаемыми программами, находящимися в $PATH

### Просмотре дерева каталогов

`ls` cписок файлов в директории

`ls -l` посмотреть расширенные свойства файлов

#### Опции
`-a` включая скрытые файлы

`-h` чтобы размер файла представлялся не в байтах, а в единицах измерения (килобайтах, мегобайтах и тд.)

`ls -lhS` отсортировать в порядке уменьшения размера

`ls -lht` отсортировать в порядке времени изменения

`-r` отобразить список в обратном порядке. например `ls -lhSr`

`-R`  отобразить содержимое вложенных папок

### cat

`cat` Вывести в stdout текстовый файл. 

`tac` Вывести с конца в stdout текстовый файл.

Если не указать аргумент, то cat ждет данных от stdin потока, который по-умолчанию слушает консоль. Можно ввести строчку и нажать Ctrl+D , что значит EOF (end of file).

Также cat может принимать несколько аргументов и wildcard, например.
```bash
cat movie.mpeg.0* > movie.mpeg
```
#### Опции

`-A` показать скрытые символы

`-n` вывести номера строк

### more
`more`  просмотр наподобие cat , но с постраничным просмотром

### type
`type`  Показывает тип команды. В Linux существует четыре типа команд:

* запускаемые файлы
* команды встроенные в shell (shell builtin) - быстрые
* shell function (shell keyword) - быстрые
* alias



## zless
`zless` Открыть текстовый файл упакованный gzip.   .gz

# Команды помощи

`man command`  Помощь по команде.

`q` выход

`/ слово`  Поиск. Если найдено несколько `n` переходит к следующему слову.

Существует `man man` В нем написано, что существует несколько групп команд. В самом начале указан номер `\-` это группа команды.

Можно искать по общей базе man 
```bash
man -k [regexp].
```
Но может случиться так, что в системе еще не были проиндексированы страницы man. Тогда поможет команда `mandb`

`help -m command` У многих программ есть help  Короче чем man
# Фильтры

## wc (Word count)
`wc` Количество строк, слов и байт текстового файла
### Опции 
`--bytes (c)`

`--lines (l)`

`-- words (w)` 

`-- chars (m)`

## head Показать первые n строк. 

## tail Показать последние n строк. 

По-умолчанию если ничего не указывать будут отображаться 10 строк

Последние 3 строки из файла паролей
```bash
tail -3 /etc/passwd
```
или с опцией -n что одно и то же
```bash
tail -n 3 /etc/passwd
```


Отображать файл с конца \+ при добавлении в конец
```bash
taif -f ./qshin.log  
```

## tr(translate)

Используется для замены или конвертации. Перевод регистра, замена символов
```bash
command | tr 'old' 'new' 
tr [:lower:] [:upper:] 
tr [a-z] [A-Z]
```
![Linux tr Filters1](images/image444.png)

 Замена перевода строки на пробел.
```bash
command | tr '\\n' ' ' 
```
![Linux tr Filters3](images/image199.png)

Устраняет множественный символ до одного. Опция `-s`.
```bash
command | tr -s 'one letter'   
```
![Linux tr Filters2](images/image273.png)

Заменяем пробелы на табы
```bash
echo hello my friend | tr [:space:] '\t' 
```


```bash
command | tr -d letter   Удаляет символ
```
![Linux tr Filters5](images/image431.png)

## cut  (выбрать значение из колонки)
Команда удобна для выбора колонки из файла.
```bash
cut -d(delimiter) -f(columnNumber) fileName 
```
![Linux Cut Filter1](images/image345.png)
![Linux Cut Filter2](images/image277.png)

## sort (сортировка)
```bash
sort fileName # Сортирует строки в алфавитном порядке
sort -kcolumnNumber fileName  # Выбор по какой колонке сортировать
```
![Linux Sort Filters2](images/image202.png)
### Опции
`-n` сортирует не по алфавиту, а по числовому признаку
```
sort -n -kcolumnNumber fileName  
```
![Linux Sort Filters3](images/image377.png)

`-d` сортировка в алфавитном порядке 
`-t` указать разделитель

## grep
Команда поиска строки по условию. Рекомендуется указывать строку поиска в одинарных кавычках.

Обычно используется в пайпах
```bash
command | grep `searchWord`   
cat marks.txt | grep `9` 
```
### Поиск в файлах и директориях
```bash
grep `searchWord` fileName 
```

поиск слова root во всех файлах текущей директории. 
```bash
grep 'root' * 
grep 'root' /etc/* 
```
Если укажем просто директорию, то будет ошибка, нужно указывать директорию и паттерн, либо использовать рекурсивную опцию '-R' тогда можно указать просто директорию.

```bash
grep -Rl root /etc # Рекурсивный поиск фрагмента по директориям. Удобно с -l
```

`-l` отображает не содержимое, а имя файла. Иногда ищем не сам фрагмент а просто имя файла, где встречается этот текст или регулярка.

![grep -l usage](images/grep_l_usage_1.png)


`-i` регистронезависимый поиск

![Linux Grep Filters2](images/image260.png)
```
grep -i searchWord fileName  Регистронезависимый поиск
```
![Linux Grep Filters4](images/image413.png)
```
grep -AlineNumber searchWord fileName  Отобразить n строк после найденного
grep -BlineNumber searchWord fileName  Отобразить n строк перед найденным
grep -ClineNumber searchWord fileName  Отобразить n строк перед и после
```
![Linux Grep Filters5](images/image215.png)


`-v` - используется для исключения из выдачи
Пример. Хотим найти все процессы содержащие crond выводим список процессов, но туда попадает и сам процесс поиска. 
```
ps aux | grep 'cron'
ps aux | grep 'cron' | grep -v 'grep'
```
![grep -v usage](images/grep_v_usage_1.png)

На всякий случай напишу тут тоже. Часто ищем по файловой системе и нету прав на просмотр некоторых файлов, в грепе это часто мешает. Можно устранить эти ошибки перенаправив поток ошибок в `/dev/null`
```
grep 'usr' /etc/* 2>/dev/null
```

Для расширенных регулярок нужно использовать не `grep`, а `egrep`. Например в `grep` не входит символ `?` и `+` . Можно включить опцию `-E` у `grep`

Не забудем экранировать символ {} в регулярках через `\`, когда хотим написать что-то вроде этого для поиска 2-х букв или более.
```
grep 'bo\{2\}t'
```

## sed (stream editor)

### sed как отображатель конкретных строк из файла

отобразить 4 строку в файле
```bash
sed -n 4p file 
```

### sed как удалитель строк в файлах или потоках
удалить вторую строку
```bash
sed -i -e '2d' file 
```
`-i` - interactive `-e` - edit command

### sed как редактор поток и файлов
Используется для применения регулярных выражений.

Применение к первом найденному случаю
```
command | sed 's/oldWord/newWord/'  
```
![Linux Sed Filter1](images/image122.png)

Для применения ко всем найденным
```
command | sed 's/oldWord/newWord/g' 
```
![Linux Sed Filter2](images/image221.png)
```
cat fileName | sed '/Word/d'  Удалить строку с фразой
```
![Linux Sed Filter3](images/image252.png)

Помимо замены sed используется и для редактирования файлов и потоков.
Для работы с файлами : 
```
sed -i ‘s/four/FOUR/g’ file_name
```

### sed как редактор многих файлов за одну команду

Заменить во всех файлах с расширением .txt в текущем каталоге слово hello на buy. Пишем внешний цикл который меняет счетчик, и далее счетчки используем в команде sed
```bash
for i in *.txt; do sed -i 's/hello/buy/g' $i; done
```

## awk
Одна из самых мощных и старых утилит. Целый язык в себе

Печатает только элементы второго столбца, соответствующие шаблону "pattern", используя stdin. Разделитель не указан значит используется пробел.
```
awk ' pattern {print $2} ' 
```
`-F` -  разделитель
```bash
 echo 'one two three four' | awk '{print $NF}' вывести последнее поле four
```

```bash
echo 'print fourth column'
awk -F : '{ print $4 }' /etc/passwd

echo 'print all line'
awk -F : '{ print $0 }' /etc/passwd

echo 'print fourth column if match pattern user in this row'
awk -F : ' /user/ { print $4 }' /etc/passwd

echo 'print first column if third more than 999'
awk -F : ' $3 > 999 { print $1 }' /etc/passwd
```

## Интересные примеры использования комбинаций команд

![Задание](images/bash_lab_1_descr.png)

Решение
```bash
cat /etc/passwd | awk -F : '$3>999 { print $0 }' | sort -t : -k 1 | sed 's/\/bin\/bash/\/bin\/zsh/g' > /tmp/myusers
```

![Решение](images/bash_lab_1_solution.png)

## less
простой просмотрщик файла. Именно он на самом деле показывает man странички
### Поиск
`/` поиск с подсветкой  

`n` перейти к следующему найденному фрагменту 

`N` к предыдущему 

`?` Поиск с конца файла

### Навигация
`j` перемещение вниз 

`k` перемещение вверх

`g` к началу файла

`G` к концу файла

`q` или `ZZ` выход
# Мониторинг системы
`free` Просмотр использования оперативной памяти.  `-h` вывести в GB `-m` вывести в Mb
![](images/image194.png)

Тут видно несколько колонок Сначала общий обьем памяти, далее используемая память в данный момент. Дальше важно понимать, что линукс неиспользуемую память использует для своих нужд, доступ к файлам происходит намного быстрее, если они имеются в RAM. Часто выглядит будто серверу недостаточно памяти, но это не так. Кеш освобождается тогда, когда память реально потребуется. Avaliable - кол-во памяти доступное прямо сейчас.

`df`  свободное пространство на диске (disk free). Удобнее выводить с `-h` опцией

![](images/image150.png)

`uptime` Показывает время работы системы с последного перезапуска и также среднюю нагрузку процессора за минуту, за пять минут, и за 15 минут

![](images/image32.png)

чтобы увидеть изменения в динамике полезна команда `watch uptime`. Каждые 2 секунды выполняется команда.

![](images/image452.png)

Важно понимать, что даже если 1 ядро, нагрузка процессора может быть больше чем единица. Например 2.5. Это значит, что процессор крайне перегружен. В то же время, если бы ядер было 4, нагрузка 2.5 допустима для такой системы.

`lscpu` Показывает информацию о процессоре (кол-во ядер, кол-во потоков)

![](images/image134.png)

### Top
`top` Отображат дашборд состояния системы

#### Полезные клавиши top:

- `f` Переходим в режим управления отображением. Тут можно выбрать какие поля отображать (d или Пробел) и по каким сортировка (s) 
- `M` отсортировать по памяти 
- `P` отсортировать по процессору
- `W` сохранить настройки топ в настройки пользователя
- `s` установить время обновления
- `c` показать полную команду
- `e` изменить единицы измерени памяти в основной таблице `E` - в шапке
- `m` Менять отображение памяти с таблицы на bar
- `t` менять отображение процессора
- `z` включить цветной режим
- `o` наложить фильтр Например `command=gnome %cpu>3.0` Сбросить фильтр `=`
- `u` выбрать процессы пользователя
- `k` послать kill процессу
- `С` скролинг
- `Y` перейти в режим просмотра output процесса
- `x` показать колонку сортировки `b` - bold режим
- `V` дерево процессов
  
# Партиционирование и монтирование

`findmnt` Посмотреть структуру смонтированных разделов
![](images/image5.png)

## Файловые системы

### XFS
По-умолчанию в RHEL 8 файловая система XFS.

Быстрая и маштабируемая, использует парадигму CoW(copy on write) - это позволяет отменять возвращать состояние файла к преждему состоянию, размер может быть увеличен, но не уменьшен, что является по мнению некоторых минусом

### Ex4.

Была по-умолчанию в RHEL 6. Все еще используется. Имеет обратную совместимость с ex2. Использует парадигму журналов, которая позволяет отслеживать момент изменения файла и в случае ошибок, возвращать состояние к предыдущему. Размер может быть и увеличен и уменьшен.

## XFS бекапы

`xfsdump` команда для работы с бекапами xfs файловых систем. Может создавать полные бекапы или бекапы с определенного уровня.

Создает полный бекап директории /data и записывает файл бекапа в /backupfiles/data.xfsdump
```
xfsdump -l 0 -f /backupfiles/data.xfsdump /data 
```
Восстанавлиет из файла бекапа и записывает в /data
```
xfsrestore -f /backupfiles/data.xfsdump /data 
```
`xfsrepair` команда для восстановления поломанных участков xfs

## Партиции

Партиции это области диска, которые позволяют изолировать данные. Используются для выделения памяти для определенного типа данных. Например под /home обычно выделяют отдельную партицию для изолирования доступа. У партиции есть имя. Пример /dev/nvme0m для ssd  sda для HDD дисков, /dev/vda для дисков KVM систем. Если диск HDD парциции будет с похожими названиями /dev/sda1, /dev/sda2, /dev/sda3, /dev/sda4,

Необходимые действия для использования партиции:
- выбрать тип партиции
- создать партицию через одну из утилит создания партиции
- создать файловую систему в партиции
- выполнить временный или постоянный mount

### Загрузчики
Системы различаются по типу загрузчика:
- BIOS 

    ограничены только 4-мя партициями В этой системе есть MBR (master boot record). Для преодоления ограничения на кол-во партиций используется Logical partition (партиция создаваемая внутри extended partition). Обычно extended партиция это sda4. Она обычно представляет собой все оставшееся место на диске, которое не занимают sda1-3. Нумерация logical partition начинается с 5, т.е sda5.

- UEFI (Universal Extended firmware interface)
  
  ограничения в 128 партиций. В ней используются GPT ([GUID](https://www.google.com/url?q=https://ru.wikipedia.org/wiki/GUID&sa=D&source=editors&ust=1662229049481587&usg=AOvVaw22z4U0z8_fyiMo9l9PSUxy) Partition Table)

## Отличия MBR и GPT

В настоящее время используются оба типа загрузки. Если это большой сервер, скорее всего там UEFI и GPT, если это виртуальная среда, вполне возможно, что там MBR.

![](images/image310.png)

### MBR

Часть спецификации 1981 PC

512 байт для хранения информации о загрузке

64 байта для хранения информации о партициях

Максимальное кол-во партиций 4, с максимальным обьемом 2TБ

Для использования большего числа партиций используются extended и logical партиции

### GPT

2010 год изобретения

Изобретено для преодоления ограничения MBR

128 партиций максимально

### lsbsk

`lsblk` Посмотреть block устройства

![](images/image284.png)

loop0 - примонтированный iso файл для репозитория sr0 - CD-ROM sda - партиции

## Список партиций
список партиций можно найти в /dev директории

![](images/image351.png)

А также `cat /proc/partitions`

![](images/image41.png)

## Parted (утилита для работы с партициями)

`parted путь_до_партиции_обычно/dev/name` 

![](images/image297.png)

По-умолчанию в RHEL 8. Более ранние утилиты fdisk для работы с MBR и gdisk для работы c GPT.

### Команды parted

`print` распечать информацию об устройстве, в том числе и список партиций

`mklabel` gpt для GPT или msdos для MBR. 

Создать запись о типе партиций
```
mkpart part-type name fs-type start end
```
#### Опции:
`part-type` Только для MBR. Значения `primary`, `logical`, `extended`

`name` Имя партиции. Обязательно для GPT

`fs-type` Тип файловой системы. Добавляет метаданные о типе системы, причем сама файловая система не меняется.

`start` `end` начало и конец партиции на диске. Обычно в MiB

Можно использовать mkpart без аргументов, тогда утилита будет спрашивать опции необходимые для создания партиции последовательно

`quit` выйти из утилиты parted

После добавление партиции необходимо выполнить
```
udevadm settle
```

Проверить, что партиция создалась
```
cat /proc/partitions
```

#### Пример использования parted
```
lsblk Увидим подключенные устройства
```
![](images/image12.png)

Видим, что подключен HDD диск, у которого размечены две партиции. Создадим еще одну партицию, т.к видно, что размер диска 40 G, а партиции занимают только 20G.

Войдем в `parted` с именем устройства, выведем через `print` текущие партиции

![](images/image418.png)

Видим, что у нас диск содержит MBR записи, т.к Partition Table: msdos

![](images/image256.png)

Выходим из parted и получаем оповещение, что необходимо обновить fstab

![](images/image451.png)

Возможна и другая ситуация. Предположим у нас подключился новый SSD диск.

![](images/image363.png)

Войдем в `parted`

![](images/image416.png)

Видим, что диск еще не содержит никаких записей и даже не имеет типа. Укажем тип GPT для создания GPT партиций. `mklabel gpt` для GPT или msdos для MBR

![](images/image156.png)

Теперь можно размечать партиции `mkpart  type\_or\_name start finish`

![](images/image26.png)

## fdisk (утилита для MBR партиций)

![](images/image174.png)

Все изменения будут в памяти, для их применения нужно нажать `w`.

Полезно нажать `m` и увидеть справку по командам

![](images/image291.png)

Список партиций `p`

![](images/image48.png)

Создадим партицию `n`

![](images/image83.png)

Т.к MBR допускает только 4 партицию, 4-ую партицию сделаем extended для возможности разделения на подпартиции

![](images/image372.png)

Команда понимает, что осталась свободной только одна партиция и предлагает выбрать тип e (extended)

![](images/image231.png)

Для сохранения результатов наберем `w`

![](images/image88.png)

Если теперь создадим новую партицию, она будет создаваться внутри адресов 4-ой партиции.

![](images/image65.png)

Иногда при операциях с партициями могут возникнуть ошибки занятости партиции. Для их идентификации можно выполнить команду `partprobe`

## Утилиты для создания файловых систем (форматирования)

После создания партиции необходимо создать файловую систему в ней. В RHEL есть несколько утилит, начинающихся с mkfs. Введем команду и нажмем два раза TAB, чтобы увидеть все варианты

![](images/image289.png)

Создадим xfs систему в созданной ранее партици

![](images/image241.png)

## Mount партиций
### Временный mount

После того как партиции созданы и в ней создана файловая система, можно сделать mount партиции, т.е присоединить к дереву каталогов FHS.

Для временного mount используется команда 
```
mount /dev/partition\_name to\_dir`f
```
![](images/image6.png)

Команда lsblk показывает не только список устройств и партиций, но и точки монтирования партиций

![](images/image170.png)

для того чтобы отсоединить партицию от каталога используется
```
umount /dev/partition\_name или partition\_mount_directory
```
![](images/image62.png)

Если вызвать команду mount без аргументов, отобразится список всех mount точек системы. Довольно большой

![](images/image364.png)

полезно отобразить mount реальных устройств
```
mount | grep ‘^/’
```
![](images/image312.png)

При операции umount могут возникнуть ошибки в случае, если файлы заняты чем-то. Например, если примонтируем партицию, далее зайдем в каталог и попытаемся сделать umount

![](images/image31.png)

Чтобы понять кто заблокировал каталог, используется команда 
```
lsof path
```
![](images/image97.png)

Также стоит помнить, что **после перезагрузки системы, точки монтирования слетят**.

### Постоянный mount через fstab

`/etc/fstab` Файл конфигурации постоянного монтирования партиций

Точки монтирования из этого файла загружает `systemd-fstab-generator` и создает `systemd mount`. Также `systemd mount` можно создавать и самостоятельно, без `fstab`.

После редактирования файла для применения изменений необходимо выполнить 
```
systemctl daemon-reload
```

Отредакируем файл /etc/fstab

![](images/image107.png)

![](images/image92.png)

Выполним команду `systemctl daemon-reload`, далее создадим директорию для точки монтирования, которую указали в fstab. Потом применим `mount -a` для того, чтобы применить точки монтирования из fstab. Далее убедимся, что точка монтирования создана

![](images/image71.png)

### mount через systemd mount

Точки монтирования описываются в .mount файлах. В файлах можно более детально описать зависимости точек монтирования, например последовательность монтирования. Монтирование можно включать и выключать по требованию. В fstab прописываются постоянно активные точки монтирования. Рассмотрим на примере файл tmp.mount

![](images/image161.png)

Тут важная часть Mount. Описывается что монтируем и куда, также тип файловой системы.

Поменяем точку монтирования, которую создали ранее в `fstab` на `systemd mount`.

Откроем `fstab` и уберем строчку монтирования.

`/etc/systemd/system` каталог для пользовательских файлов .mount

Проще всего создавать mount, копируя уже созданный mount в директорию и подправляя как необходимо.
```
cp /usr/lib/systemd/system/tmp.mount /etc/systemd/system/movies.mount
```
Название не призвольное, оно отражает куда будет осуществляться монтирование. Т.е movies.mount будет монтироваться в /movies. Для указания вложенности используется дефис. Например data-movies.mount указывает на /data/movies

![](images/image4.png)

Для того, чтобы systemd забрал изменения из файлов конфигураций выполним.
```
systemctl daemon-reload
```
Выведем статус movies.mount

![](images/image27.png)

Обратим внимание на путь. Он таков потому, что точка монтирования уже была и mount сгенерирован из fstab. Для того, чтобы путь изменился, необходимо перемонтировать точку.

![](images/image262.png)

![](images/image45.png)

![](images/image434.png)

### Automount

Монтирование ресурсов иногда удобнее организовать через automount, который позволяет включать монтирование только тогда, когда это необходимо.

файл конфигурации `/etc/auto.master`

файл содержит директории вместе с файлом настройки монтирования для этой директории

![](images/image392.png)

например `/data  /etc/auto.data`. Тут директория это `/data` , а в файле `auto.data` будут настройки чего будет монтировать в директорию.

Например там будет:

![](images/image168.png)

`files` это директория внутри `/data`. Далее права на чтение и запись, а дальше что монтируем, в данном случае это nfs сервер

Создание automount

1.  Установим пакет autofs
```
yum install autofs
```
![](images/image148.png)

2.  Включим сервис
```bash
systemctl enable --now autofs
```
![](images/image192.png)

После включения увидим что в `/` каталоге появились дополнительные директории `net` и `misc`

![](images/image408.png)

В файле `/etc/auto.maset` (см. выше) есть строчка с каталогом `/misc` и с файлом конфигурации для него. Посмотрим в него

![](images/image240.png)

Тут есть примеры того, как можно монтировать через autofs. Поддиректории, далее файловые системы, далее ресурсы.

3.  Создадим запись в `/etc/auto.master` с новой директорией `files`. Также укажем новый файл для конфигурации

![](images/image72.png)

![](images/image135.png)

![](images/image360.png)

4.  Рестартуем сервис autofs
```
systemctl restart autofs
```

![](images/image390.png)

5.  Увидим что создалась директория files

![](images/image251.png)

Но никаких файлов внутри нее нет

![](images/image209.png)

6.  НО если попытаемся войти в директории `data` , то команда отработает. Т.е монтирование происходит в тот момент. когда происходит обращение к ресурсу.

![](images/image125.png)

Это позволяет не тратить время на монтирование ресурсов, которые в данные момент не нужны, а монтировать их в момент использования

#### Пример настройки динамического home

В файле `/etc/auto.master` укажем

![](images/image349.png)

в файле настроек `/etc/auto.ldap` укажем

![](images/image283.png)

![](images/image427.png)


## Именование устройств (UUID, Label)

В процессе работы с партициями могут возникнуть неприятная ситуация. Когда заполняем fstab точками монтирования указываем путь до партиции, точнее ее имя. Что произойдет, если мы удалим партицию 4, а у нас была партиция 5. Произойдет ошибка при запуске системы, т.к партиция с именем 5 станет партицией 4. Для того, чтобы этого не произошло у партиции есть уникальный UUID, который автоматически создается при создании файловой системы. А также можно создать собственный LABEL, для именования партиции.

Пример проблемы:

Создадим две логических партиции внутри extended партиции.

![](images/image108.png)

![](images/image163.png)

Создали две партиции. 

Через команду `blkid` можно увидеть информацию об Id партиции.

![](images/image380.png)

Видим, что у созданных партиций нет еще UUID. Т.к он создается при создании файловой системы. Создадим их. Для примера сделаем xfs и ext4

![](images/image304.png)

![](images/image450.png)

Далее выведем через `blkid` информацию и увидим, что UUID сгенерировался.

![](images/image187.png)

Добавим в `fstab` точку монтирования, в которой используются явный путь до устройства

![](images/image401.png)

![](images/image338.png)

![](images/image126.png)

А теперь удалим одну из партиций.

![](images/image395.png)

Система говорит, что сейчас удалить партицию нельзя, но после перезагрузки это будет сделано. Перезагрузим компьютер и...получим ошибку загрузки.

![](images/image29.png)

![](images/image191.png)

![](images/image178.png)

![](images/image328.png)

Возможно дело в том, что в fstab осталась запись о партиции которая была удалена?Попробуем исправить.

![](images/image337.png)

Теперь удаленную партицию закомментировали в fstab.

![](images/image233.png)

Проблема не ушла. Дело в том, что партиция 6 изменила свое имя на 5, т.к 5-ая была удалена. Видим, что только 5 партиций, а в fstab указан путь до /dev/sda6

![](images/image195.png)

Чтобы монтирование не слетало, придумано два способа UUID, который создается при формировании файловой системы. Его можно указать в fstab. А также label. Создадим метку для партиции 5 и примонтируем ее правильно. Для начала закоментируем монтирование в fstab чтобы система нормально загрузилась.

![](images/image342.png)

Создадим метку на партиции. Есть несколько утилит для этого `tune2fs` (для ext файловых систем) и `xfs_admin` (для xfs)

Создадим метку для партиции
```
tune2fs -L movies /dev/sda5
```
![](images/image111.png)

далее поменяем точку монтирования в `/etc/fstab`

![](images/image141.png)

![](images/image46.png)

Теперь будет не важно, если название партиции поменяется. Также можно написать UUID, но он не будет настолько читаемым. В картинке наверху видно, что /boot монтируется именно через UUID

Также есть каталог `/dev/disk , где расположены ссылки на партиции и устройства по различным критериям

![](images/image357.png)

## SWAP партиции

Создадим swap-партицию.

![](images/image242.png)

![](images/image385.png)

После создании партиции необходимо создать файловую систему на ней командой
```
mkswap partition_path
```
![](images/image254.png)

Создали файловую систему на своп-партиции. Далее необходимо присоединить партицию к свопу командой 
```
swapon partition
```
![](images/image208.png)

Это не персистентное монтирование. Для постоянного монтирования необходимо либо отредактировать `/etc/fstab` , либо создать mount файл в `/etc/systemd/system`

![](images/image52.png)

Можно использовать команду `swapon -a` , которая применяет точки монтирования swap из fstab

## LVM Logical volumes

### Physical volume, logical group, logical volume. Создание

Использьуются по-умолчанию при установке RHEL. Можно изменять размер, делать снепшоты и пр.

![](images/image115.png)

Суть простая: группы дисков, партиций обьединяем в группу с определенным именем. Это Volume Group. Из volume Group создаются logical volume, которые никак не соотносятся с физическии устройствами. Т.е физические устройства обьединяются в большой пул памяти, который уже разделяется на произвольное кол-во logical volume. Группы можно монтировать в директории, создавать в них различные файловые системы. Находятся в /dev/vg/

В отличие от реальных дисков могут logical volume. могут содержать очень большие обьемы данных. Например имеем 2 по 1TB диска, обьединяем их в volume group и можем создать одну группу 2TB, будто бы на одном устройстве. Т.е деление logical volume может быть совсем другим нежели physycal volume

Для создания партии, способной учавствовать в volume group
```
parted  и далее команда set number_partition lvm on
```

создать партицию 

![](images/image344.png)

Тип файловой системы неважен, т.к все равно будет создавать новую файловую систему при создании logical volume

![](images/image68.png)

для создания physical volume
```
pvcreate /dev/sda3 
```
![](images/image446.png)

командой `pvs` просматриваем список **physical volumes**. Видим, что у sda Volume group еще не указана
```
vgcreate vgdata /dev/sda3 для создания volume group
```
![](images/image151.png)

Видим, что volume group теперь указана. Также командой `vgs` просмотрим список **volume groups**

![](images/image306.png)
```
lvcreate -n lvdata -L 1G vgdata для создания logical volume
```

Командой `lvs` увидим список **logical volumes**
![](images/image346.png)

создадим файловую систему в logical volume
```
mkfs.file_system /dev/vgdata/lvdata
```
![](images/image347.png)

создадим точку монитирования в fstab

![](images/image119.png)

![](images/image1.png)

![](images/image30.png)

### Изменение размера logical volume

![](images/image412.png)

При необходимости увеличения размера **logical group** нужно понимать, доступно ли свободное место в **volume group**. Для этого поможет команда `vgs`. 
Если доступно свободное место, тогда применяем команду 
```
lvextend -r.
```
Увеличит volume на 1Гб, за счет volume group. Увеличение произойдет и в файловой системе
```
lvextend -r -L +1G
```

Если забыли флажок r, то существуют утилиты для увеличения непосредственно в файловой системе: `e2resize` для Ext-файловых систем, `xfs_grows` для xfs. Уменьшение размера невозможно.

Если в volume group нет свободного места придется присоединять к volume group другие устройства командой `vgextend`.

Хотим увеличить размер logical volume

![](images/image300.png)

Видим, что volume group имеет 0 доступных мегабайт. Придется добавлять туда свободного диска.![](images/image399.png)

## Stratis

Новое поколение разделения разделов. Появилось в RHEL8.  Он реализован в пользовательском пространстве, что также делает возможным доступ к API, что означает, что к нему можно обращаться из разных приложений, что является полезным решением, где используются облака, виртуализация или контейнеры

Технология от RedHat. Конкурент ZFS и Btrfs. Поверх при необходимости XFS. Может строится на любом блочном устройстве, в том числе LVM, но не на партиции

Преимущества:

* thin provisitoning Может представить из себя 10 ТБ, хотя данных будет на 500 мегабайт.
* Снепшоты \- бекапы
* Слой кеша. Может быть доступен из программ.

Stratis Pool состоит из одного или нескольких устройств. Создается директория для каждого пула `/dev/stratis/my-pool`, в которой содержатся ссылки на устройства помещенные в пул. Поверх volume создается XFS. Но каждый пул может иметь и несколько файловых систем.

Устанавливаем эти пакеты для работы со Stratis
```
yum install stratis-cli stratisd
```
![](images/image7.png)

Активируем stratisd сервис
```
systemctl enable --now stratisd 
```
![](images/image58.png)

Cоздаем stratis pool на основе устройства. Партиции не поддерживаются. Минимальный объем 1 ГБ
```
stratis pool create mypool /dev/sdb 
```

![](images/image175.png)

![](images/image330.png)

Создаем файловую систему XFS
```
stratis fs create mypool myfs1 
```
![](images/image77.png)

![](images/image375.png)

Отображаем список файловых систем в пуле.
```
stratis fs list mypool 
```
![](images/image423.png)

 Создадим каталог для точки монтирования
```
mkdir /myfs1
```
Смонтируем
```
mount /dev/stratis/mypool/myfs1 /myfs1 
```
![](images/image19.png)

Отобразим список пулов Stratis
```
stratis pool list 
```
![](images/image139.png)

Отобразим список файловых систем
```
stratis fs list 
```
![](images/image121.png)

Отобразим список устройств через `lsblk`

![](images/image109.png)

Увидим, что монтирование насоздавало кучу длинных названий в sdb. Именно поэтому рекомендуется монтировать через UUID.

![](images/image185.png)

Скопируем UUID и вставим в fstab

![](images/image280.png)

### Изменение размера stratis volume

Stratis pool может быть увеличен добавлением еще одного устройства.

```
stratis pool add-data mypool /dev/sdc 
```

### Снепшоты

* Снепшоты это индивидуальная файловая система, которая может быть замонтирована
* После создания снепшот можно изменить
* Снепшот и оригинальный образ никак не связаны
* Каждый снепшот должен содержать минимум половину гигабайта на лог xfs
  
Cоздаем снепшот существующей файловой системы. Причем изменения в оригинальном обьекте никак не отразятся на снепшоте.
```
stratis fs snapshot mypool myfs1 myfs1-snapshot 
```
![](images/image87.png)

![](images/image75.png)

Монтируем снепшот
```
mount /stratis/mypool/myfs1-snapshot /mnt 
```
![](images/image232.png)

Заменить оригинальную файловую систему на снепшот
```
umount /myfs1
stratis fs destroy mypool myfs1
stratis fs snapshot mypool myfs1-snapshot myfs1
```

Снепшоты Stratis не работают с устройствами LVM

Удалить снепшот
```
stratis fs destroy mypool myfs1-snapshot 
```

Удалить файловую систему
```
stratis fs destroy mypool myfs1
```

Когда в пуле нет файловых систем, можно удалить пул.

Особенность. Если посмотреть df -h , увидим довольно странные данные.

![](images/image384.png)

1 Терабайт для точки монтирования, хотя у нас гораздо меньше физические диски в stratis пуле.Не нужно смотреть использование через df в случае с Stratis пулом.

## VDO-виртуальный оптимизатор данных

Появился в RHEL 8. Фокусируется на наиболее эффективном хранении файлов, управляет дедуплицированными и сжатыми пулами хранения. А в остальном похоже на Stratis.

Минимум 4 GB должно свободны на устройстве.

Устанавливаем пакеты vdo
```
yum install vdo kmod-kvdo 
```
![](images/image429.png)

Создаем vdo
```
vdo create --name=vdo1 --device=/dev/sdd --vdoLogicalSize=10T 
```
![](images/image152.png)

Создаем файловую систему
```
mkfs.xfs -K /dev/mapper/vdo1 
```
![](images/image341.png)

Применяем изменения в наименованиях устройств
```
udevadm settle 
```
![](images/image211.png)

Монтируем 
![](images/image419.png)

Обязательно указываем `x-systemd.requires=vdo.service`

Мониторинг vdo
```
vdostats --human-readable 
```
![](images/image189.png)

## LUKS encrypted volume

Используются партиции. Т.е нужно создать партицию , через parted, либо fdisk или gdisk

![](images/image95.png)

![](images/image124.png)

Создает заприптованный уровень над партицией
```
cryptsetup luksFormat  
```
![](images/image422.png)

“Открыть” устройство
```
cryptsetup luksOpen name\_of\_device  
```

После этого создается устройство `/dev/mapper/name\_of\_device`
![](images/image38.png)

Далее необходимо создать файловую систему на новом устройстве и замаунтить
![](images/image398.png)

Если кто-то сопрет диск, он не сможет открыть это устройство, т.к необходим пароль.

Для автоматизации “открытия” устройства при старте используется `/etc/crypttab`
а для монтирования устройства `/etc/fstab`
![](images/image89.png)
![](images/image454.png)

мануал 
```
man crypttab
```

При перезагрузке системы появляется окно
![](images/image157.png)

Если несколько раз ввести пароль неправильно или не вводить, система все равно загружается, но секретное устройство не монтируется.


# Переменные окружения

Показать все переменные окружения
```
 printenv или env       
```

Показать опреденную переменную
```
printenv JAVA_HOME 
```

## Переменные сессии
Если присваиваем переменную в терминале или скрипте 
```
LANG=he_IL.UTF-8
```
и она уже существует, то перезатирается в текущей сессии, но не глобально. Если не существует, то ее называют *shell variable*, которую можно экспортировать во временную переменную окружения `export LANG`, а можно и сразу с присваиванием `export LANG=he_IL.UTF-8`

## Установка с сохранением после перезапуска 

### для всех пользователей
1.  Файл **/etc/environment**    В нем просто через *=* перечисляем переменные, нельзя пользоваться ссылками через *$*
2.  Каталог **/etc/profile.d**  Там можно написать скриптик .sh в котором написать что-то вроде этого.
```
export JAVA_HOME=/usr/lib/jvm/jdk1.7.0  
export PATH=$PATH:$JAVA_HOME/bin
```

### для конкретного пользователя
```
echo 'export PATH=$PATH:/usr/local/go/bin' >> $HOME/.profile
source $HOME/.profile
```

## Разница profile и bashrc

Когда пользовать логиниться запускается скрипты /etc/profile скрипты /etc/profile.d а также скрипт домашнеий директории ~/.profile
Когда стартует sub-shell при запуске почти любой команды из скрипта, то запускается /etc/bashrc и файл из домашней директории ~/.bashrc
Когда пользователь разлогинивается запускается скрипт ~/.bash_logout


# Vim

Все команды иcполняем в командном режиме. Находимся в нем сразу при запуске. Вернуться в него из других режимов нажать `Esc`. Перейти в режим редактирования `a` или `i` или `Insert`

## Команды выхода

`:w` сохранить

`:q` выйти

`:wq` Сохранить и выйти 

`:q!` выйти и не сохранять

## Исправления действий

`u` Отменить действие\

`ctrl r`  Вернуть действие

## Навигация

`j` вниз 

`k` вверх 

`h` лево 

`l` право

`G` перейти на последнюю строчку файла

`2G` перейти на вторую строчку файл и так далее

`gg` перейти в начало файла

`0` начало строки 

`$$` конец строки

Переход по скобкам:
В тексте, где встречаются ) } \]  перейти к соответствующей скобке `%`   т.е `Ctrl + 6`

## Команды редактирования

`dd` удалить строку 

`d$` удалить с текущего места и до конца строки

`yy` копировать строку 

`y` скопировать выделение 

`p` вставить

## Режим выделения

`v` переход в визуальный режим. Текст при движении выделяется. С ним что-то можно сделать например `x`  или `r` или `d`

## Разное

`.` Повторить предыдущую команду

`100 + i + Dima + Esc` Ввести много раз одно и тоже. 

Также можно вводить или стирать например 50 новых строче `50 + i + Enter + Esc`

`b` начало слова    

`e` конец слова

`w` начало следующего слова

можно перемещаться  вперед `eeee` `wwwww` или назад `bbbbb`

можно много раз вперед `100 + e`

`Ctrl X + Ctrl F` автодополнение файлов в процессе набора

`x` стереть символ под курсором

`X` стереть символ слева от курсора

Заменить символ под курсором не переходя в режим insert. `r символ`

Удалить `d` совмещается с символами движения. Например удалить 2 слова `d2w`

## Поиск

Поиск c начала файла `/` введем слово потом `Enter` nперейти к следующему `shift n` к предыдущему `.` Можно вводить регулярки

Также можно искать с конца файла `? затем слово и Enter`

Найти текущее слово вперед `*` т.е ctrl 8

Найти текущее слово назад `#`   т.е ctrl 3

`:noh` сбросить выделение

## Замена

`:%s/old/new/g`

# Ссылки Links 

В линуксе два типа ссылок : hard links и symbolic links.

У каждого файла в системе, есть так называемый inode (указатель на файл в памяти). Hard link указывает на inode. Может быть несколько имен у файла, каждое имя или hard link указывает на inode. Причем у inode есть числовое поле, в котором содержится число hard линков, которые указывают на него. Symbolic link указывает на hard link

Создадим hard link на файл etc/hosts
```
ln /etc/hosts ./hard_hosts
```
![](images/image78.png)

Выведем список файлов и увидим, что ссылка на inode у двух файлов одинаковая

![](images/image131.png)

Создадим symbolic link
```
ln -s /etc/hosts symbol_hosts
```
![](images/image162.png)

Удалим файл /etc/hosts и увидим, что simbolic link сломался

![](images/image63.png)

Но ничего страшного, можем запросто восстановить прежний файл, т.к как таковой файл у нас есть, просто нужно создать hard link

![](images/image127.png)

Создать symbolic link
```
ln -s /path/to/file /path/to/symlink 
```

Отредактировать symbolic link
```
ln -sf /path/to/file /path/to/symlink 
```

Создать ссылку на var в текущей директории
```
ln -s /var .  
```

# Операции с архивами

## tar

Используется для архивации директории. Для опций \- необязателен.
```
tar OPTIONS name_of_archive directory_names...
```

### Опции tar:

`с` создать 

`v` отображать процесс в stdout 

`f` для указания названия целевого файла

`z` использовать ли компрессию gzip

### Запаковать директорию
```
tar cvfz office.tar.gz office
```

также можно направлять в gzip напрямую через piping

![Linux gzip Filters4](images/image226.png)

### Распаковать директорию
`x` Распаковать архив в текущую директорию 

```
tar -xvf имя_архива
```

Можно указать расположение целевой директории

```
tar -xvf articles.tar -C /tmp/my_article/
```

`t` Показать содержимое архива  

```
tar -tvf имя_архива
```

## gzip

Команда архивации. По-умолчанию файл будет помещен в архив с расширением (.gz). Причем оригинальный файл пропадет. `-k` сохранить оригинальные файлы.              Если файлов передано несколько, будет создано несколько архивов. Для обратной операции есть команда `gunzip`

```
gzip file1 file2 file3...  
```

```
gunzip file1 file2 file3...  
```
![Linux gzip Filters1](images/image182.png)

`-l` Показывает после архивации как сильно был сжат архив

![Linux gzip Filters3](images/image428.png)

# Структура каталогов FHS

для RetHat описывает структуру каталогов. Для debian не работает.
```
man hier
``` 

`/boot/vmlinuz` ядро линукса. Команда `file` дает детальную инфу о нем.

`/dev` Устройства компьютера показанные в виде файлов

`/etc/` Файлы конфигураций

`/etc/fstab` файлик где примаплены физические устройства, когда система загружается.

`/etc/hosts` Файлик с мапингом ip адресов и имен

`/etc/init.d` Скрипты запускаемые при загрузке. Можно сюда всандаливать свои

Для RedHad 
`/etc/redhat-release` Файл с именем версии

НО для всех систем  `/etc/os-release`

![](images/image414.png)

![](images/image203.png)

`/bin` `/usr/bin` Программы для системы и для пользователя

`/sbin` `/usr/sbin` Программы для администрирования

`/usr/local` Программы и файлы для пользователя. Если хотим установить программу, которая не входит в дистрибутив, то ставим ее сюда, либо в `/usr/local/bin`

`/var/log` Файлы лога операционной системы

`/lib` Библиотеки операционной системы

`/tmp` Временные файлы программ

`/proc` Виртуальная директория. Тут список процессов плюс инфо об устройствах. Например `/proc/cpuinfo`

# Поиск

## find Поиск файлов в директории

Поиск по имени
```
find . -name "*.txt"   
```

![Linux Find1](images/image308.png)

поиск по типу
```
find . -type d -name "*.bak"  
```

`f` файл

`d` директория 

`l` symbolic links 

`c` character devices 

`b`  block devices

![Linux Find2](images/image329.png)

Поиск файлов по всей системе больше превышающих размер 100 Мб
```
find / -type f -size +100M
```

![](images/image334.png)

Можно задавать последующие команды через опцию `-exec`
```
find /etc -size -1000с -exec cp {} /tmp/files/ \\;
```

## locate
```
locate fileName
```
Команда позволяет искать файлы. Но в отличие от `find` она ищет в базе данных файлов. Поэтому поиск значительно быстрее. Если файл не находится, вполне вероятно, что база данных файлов устарела, тогда поможет команда `updatedb`

# Cockpit

штука для удаленного мониторинга.

[https://cockpit-project.org/running](https://www.google.com/url?q=https://cockpit-project.org/running&sa=D&source=editors&ust=1662229049530269&usg=AOvVaw1rwlFY9JL9iytzVuXoFJdH)

## Установка
для RHEL 7  
```
sudo subscription-manager repos --enable rhel-7-server-extras-rpms
```

для RHEL 8 не нужно прописывать репозиторий
```
sudo yum install cockpit Установка
```

## Запуск и проверка

```
sudo systemctl enable --now cockpit.socket
sudo systemctl status cockpit.socket
```

Если прописаны не стандартные правила firewall
```
sudo firewall-cmd --add-service=cockpit
sudo firewall-cmd --add-service=cockpit --permanent
```
![](images/image82.png)

# Midnight Comander

`Ctrs + s`  Быстрый поиск в текущей директории

`Alt + e`  Кодировка

`*` выделить по паттерну

В диалоге поиска можно искать по истории `Ctrl + UP` `Ctrl + Down`

`\` убрать выделение по паттерну

`alt + *`   инвертировать выделение

`alt + i` отобразить текущую директорию на другой панели

`alt + u`   `alt + y`  ходим по каталогам в истории

можно запустить mc без всяких цветов. `mc - b`

`F3` смотреть файл

`F4` редактировать файл. Обычно открывается vim

`Shift F4` создать новый файл

`Alt + Enter` Внести текущий выделенный обьект в командную строку

`Alt + a` Внести путь до текущей панели в комадную строку

`alt + c` быстрый переход cd из текущей панели. Увы без подсказок TAB

`alt + o`  Открываем выделеную директорию в другой панели. Удобная штука

`alt + n, alt + p` ходим по истории команд в командной строке

`alt + t`  меняем вид панели. Полный, короткий, длинный

`alt + shift + h` Показать историю директорий

`alt + shift + ?`   Диалог поиска

`ctrl + o`   Скрыть панели показать

`Ctrl-R` Обновить директорию

`alt + .` Показывать скрывать все скрытые файлы

`alt + ,` Горизонтальный вертикальный режим

`F9` Выделить строчку меню

Иногда пересекаются команды окна и комадной строки или внешней оболочки. Для экранирования используется клавиша `Esc`

`Ctrl-x q`   Режим просмотра файлов. Справа панель, слева текст.
КАк нажимать:   Сначала `ctrl + x`   потом отпускаем обе и нажимаем `q`

## Избранные директории в mc

Добавить директорию  `Ctrl + x, h`

Открыть список `ctrl + \`

## Цветовая схема

Часто необходимо поменять цветовую схему
Готовые темы оформления (skins) после установки Midnight Commander располагаются по пути:
```
 ll /usr/share/mc/skins
```

Туда можно заглянуть и выбрать, что понравиться:
```
~|⇒ ll /usr/share/mc/skins  
total 212K  
-rw-r--r-- 1 root root 3,0K Dec  5  2013 darkfar.ini  
-rw-r--r-- 1 root root 3,0K Dec  5  2013 dark.ini  
-rw-r--r-- 1 root root 2,7K Dec  5  2013 default.ini  
и тд
```

некоторые темы используют 256 цветов. Для переключеия в этот режим достаточно поместить этот скрипт в `.bashrc`

```
|     |     |
| --- | --- |
| \# Some terminal games can't handle 256 color TERM types |     |
|     | \# Can't use screen-256color because it conflicts with some |
|     | \# window tab settings. |
|     | \# Can't use putty-256color because MoTTY (PuTTY) is in xterm |
|     | \# mode. |
|     | \# Since MXT always runs a login shell for anything run from |
|     | \# the menu, select TERM based on the command run. |
|     |     |
|     | case"$BASH\_EXECUTION\_STRING"in |
|     |     |
|     | *ctris*) TERM=xterm;; |
|     | *ninvaders*) TERM=xterm;; |
|     | *) TERM=xterm-256color;; |
|     | esac |
|     |     |
|     | export TERM |
```

Всё, можно использовать указывая тему явно:
```
$\> mc -S xoria256
```

Либо указав новую тему в файле `~/.mc/ini`

```
$\> mcedit ~/.mc/ini
```

Найдите внутри строку вида `«skin=default»` и замените на `«skin=xoria256»`
НО это делать нужно не запуская mc, иначе тема будет перетираться на дефолтную

## Открывать файлы через приложения windows
Если используем cygwin , то удобно, чтобы файлы открывались многие также как и в windows. Для этого находим `/etc/mc/mc.ext`

там прописаны правила для различных расширений.

В конце есть секция ее заполняем так
```
default/*
        Open=cygstart %p
        View=
```

Если выше уже указано правило по работе с расширением и нам оно не подходит просто комментируем его и будет запускаться дефолтная программа

# Разные команды
## comm (сравнение файлов)

Сравнивает два файла или два потока. По-умолчанию отображаются три колонки. В первой отображаеются не совпадающие фрагменты из первого файла, во второй не совпадающие фрагменты во втором файле, в третьей совпадающие фрагменты. Оба файла должны быть отсортированы, т.е сравнение содержимого строк построчно.

```
 comm file1 file2
```

```
 comm file1.txt file2.txt  
```

![Linux Comm Filter1](images/image379.png)

### Отобразить только одну колонку

Нужно указать опцию, она представляет собой порядковые номера с 1 колонок, которые показывать не нужно

отобразить первую колонку
```
comm -23 file1.txt file2.txt
```

отобразить вторую колонку
```
comm -13 file1.txt file2.txt
```

отобразить третью колонку
```
comm -12 file1.txt file2.txt
```

![Linux Comm Filter2](images/image276.png)

## tee. Запись в файл с возможность перенаправить stdout дальше

Выводить stdin поток в stdout а также в файл. Можно использовать в цепочках команд, чтобы что-то залогировать и одновременно не потерять вывод для следующей команды.

```
cat or tac fileName| tee newFile |  cat or tac |.....  
```

```
tac weeks.txt | tee new.txt | cat  
```

![Linux tee Filters](images/image447.png)

## uniq

Позволяет создать сортированный лист, в котором каждое слово встречается только один раз

```
command fileName | uniq  
```

```
sort dupli.txt | uniq  
```
![Linux Uniq Filters1](images/image55.png)

`uniq -c` считать число дублей каждого слова в списке

```
command fileName | uniq -c  
```

```
 sort dupli.txt | uniq -c  
```

![Linux Uniq Filters2](images/image394.png)

## Команды для работы со временем

`date` Отображает текущую дату
![Linux Date1](images/image129.png)

также можно описать формат, в котором отображать дату
![Linux Date2](images/image169.png)

`cal` Отображает календарь
![Linux cal1](images/image400.png)

`cal month year`
![Linux cal2](images/image103.png)

`sleep 5` Команда заставляет терминал остановиться на определенное время. По-умолчанию в секундах.
![Linux Sleep](images/image158.png)

`time` Команда показывает, как долго работают другие команды

![Linux Time](images/image229.png)



# Open SUSE

Настроить прокси

`/etc/syconfig/proxy`

`HTTP_PROXY="http://myusername:mypassword@myproxy.example.com:8080"`

Подключить общую папку
`sudo mount -t vboxsf wd ~/host`

# Запуск процессов по расписанию

Существует 3 способа. Cron (самый мощный и разнообразный) at (запуск один раз) и systemd timers (современный способ)

# Cron

Добавить правило для текущего пользователя 
```
crontab -e
```

Посмотреть для текущего пользователя
```
crontab -l
```

Вышестоящими командами правила добавляются в файл `/var/spool/cron/%username%.` Но посмотреть явно этот файл может только root

Если нужно добавить переменные для всех пользователей создаем файл в каталоге `/etc/cron.d`

![](images/image440.png)

тут могут лежать файлы со стандартными названиями hourly, daily, weekly, а также другие файлы с произвольными правилами

![](images/image201.png)

Кроме cron.d существуют и другие каталоги для помещения правил. Их названия говорят сами за себя. В этих папках могут располагаться скрипты, которые будут запускаться в соответствии с временным интервалом названия папки. Правила прописывать не нужно, достаточно поместить скрипт файл в папку.

![](images/image73.png)

Также существует устаревший способ, добавление в `/etc/crontab`

За запуск скриптов из папок cron.(периодичность) отвечает `anacron`, конфигурация которого в `/etc/anacrontab`. Тут важно заметить, что в anacrontab конфигурируется запускаемость скриптов из папок cron.weekly, cron.monthly, cron.daily, но не cron.hourly. За hourly отвечает скпипт `0hourly` в каталоге `/etc/crod.d`.

\* \* \* \* \*    минута, час, день, месяц, день недели. Если все оставить звездочками, то значит каждую минуту.

Могут быть и противоречивые записи.

*/10 4 11 12 1-5    Каждые 10 минут, 4 час,  11 день месяца, 12 декабрь. 1-5 по будням. Будет выполняться только в декабре, 11 числа и по-будням каждые 10 минут.

Скрипты не должны писать в stdout, команда упадет, если попробует писать в stdout. Следовательно нельзя, к примеру, использовать команду echo. Необходимо писать в syslog.

Посмотрим на дату:

![](images/image90.png)

Для текущего пользователя заведем правило, чтобы каждую минуту в syslog писалось Good day. А также сделаем это и для root

![](images/image171.png)

![](images/image271.png)

![](images/image313.png)

Иногда бывает трудно вспомнить правила cron .

Полезна команда `man 5 crontab`

Для того, чтобы запустить автоматически скрипт после перезагрузки

в каталоге `/etc/cron.d` делаем файл

`@reboot   root        /home/osboxes/scripts/antscript`

## at

Для запуск однократно команды в определенное время существует сервис atd.

`at time` запланировать job. При этом открыватеся интерактивный shell, куда можно вписать одну или несколько команд. Чтобы выйти нужно нажать `Ctrl D`

При этом сервис atd должен быть запущен.

![](images/image101.png)

![](images/image324.png)

`atq`  вывести список запланированных джобов

![](images/image61.png)

`atrm`  удалить джобу

![](images/image269.png)

# Временные файлы systemd-tmpfiles

В каталоге `/etc/lib/tmpfiles.d` находятся настройки создания, удаления и очистки временных файлов

`systemd-tmpfiles-clean.timer` Юнит, который может быть настроен для удаления временных файлов. Он запускает `systemd-tmpfiles-clean.service`. Сервис определяет что делать, таймер определят когда делать. Сервис запускает команду, которую можно выполнить и напрямую  `systemd-tmpfiles --clean`

Настройки таймера
```
systemctl cat systemd-tmpfiles-clean.timer 
```
![](images/image2.png)

Тут видим, что таймер стартует через 15 минут после старта. Период между запусками 1 день.

В файле `/usr/lib/tmpfiles.d/tmp.conf` находятся настройки автоматического удаления файлов из директории `/tmp`

Рекомендуется для того, чтобы правила применились для всей системы после изменений в файле `/usr/lib/tmpfiles.d/tmp.conf` скопировать его в `/etc/tmpfiles.d/tmp.conf` После правки этого файла его можно проверить на корректность, выполнив команду
`systemd-tmpfiles --clean /etc/tmpfiles.d/tmp.conf`

В файле `tmp.conf` располагаются настройки: какие директории мониторить, какие права доступа установлены на эти директории, какой пользователь является владельцем файлов, сколько дней файлы будут жить прежде чем будут удалены. Для помощи существует стриничка помощи `man tmpfiles.d`

![](images/image393.png)

![](images/image210.png)

Создадим кастомную конфигурацию.

![](images/image15.png)

![](images/image91.png)

![](images/image370.png)

Видим, что файл все еще остался. А все потому, что таймер включен, но настроено в нем, что запускается он раз в день.

Можно вызвать команду напрямую.

![](images/image110.png)

# Virtual Box

часто при создании ВМ при старте появляется Kernel panic. Нужно проверить сколько выделено ядер процессора, скорее всего 1-но и из-за этого и происходит эта ошибка. 

## mnt дисков

Возникли сложности при маунте дисков внутрь Ubuntu Server. Проблема была в том, что обязателен GuestAddition.iso , но он почему не применялся при добавлении, пришлось искать решение, вот оно:

https://gist.github.com/magnetikonline/1e7e2dbd1b288fecf090f1ef12f0c80b

- Create Ubuntu server instance under VirtualBox (obviously).
- Start VM, goto **Devices - Insert Guest Additions CD image** to mount the ISO image.
- From the terminal, run the following commands:

	```sh
	$ sudo su
	$ apt install gcc make
	$ mkdir --parents /media/cdrom
	$ mount /dev/cdrom /media/cdrom
	$ /media/cdrom/VBoxLinuxAdditions.run
	$ reboot
	```

- After reboot:

	```sh
	$ modinfo vboxguest
	$ sudo usermod --append --groups vboxsf -- "$USER"
	$ cat /etc/group | grep "$USER"
	```

- Host shares should now be mounted in Ubuntu guest under `/media` via the installed `VBoxService` service, set to start on system boot-up.
- All done.

**Note:** the above steps can be repeated on an existing VM image for guest addition upgrades, `VBoxLinuxAdditions.run` will handle the uninstall and reinstall process automatically.


Noted from comment:

* Log out and back in again after adding user account to vboxsf group


## Настройка сети

в режиме NAT. Извне из локальной сети пробиться к виртуалке будет невозможно, зато из виртуалки можно проходить во внешнюю сеть. Более того из системы хоста можно заходить на виртуальную машину через ssh ,  для этого необходимо настроить проброс портов

![](images/image449.png)

Удобнее всего настроить в режиме Bridge. Когда вируальная машина регистрируется в локальной сети через DHCP роутера и является полноправным участником сети ( не только хостовая система может заходить на виртуалку и проброс портов настраивать не нужно)

![](images/image197.png)

[https://techlist.top/virtualbox-network-settings-part-1/](https://www.google.com/url?q=https://techlist.top/virtualbox-network-settings-part-1/&sa=D&source=editors&ust=1662229049555646&usg=AOvVaw0h_78D0X_G2L5uzVpGHz_D)

## CentoOS VirtualBoxGuest

[https://linuxconfig.org/virtualbox-install-guest-additions-on-redhat-8](https://www.google.com/url?q=https://linuxconfig.org/virtualbox-install-guest-additions-on-redhat-8&sa=D&source=editors&ust=1662229049556025&usg=AOvVaw3BWyFTUy2tkU5JnUrHBTFX)

Вызываем эту команду
```
root@osboxes:/home/dima# lsblk

NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT

loop0    7:0    0 86.9M  1 loop /snap/core/4917

loop1    7:1    0 87.9M  1 loop /snap/core/5662

sda      8:0    0  500G  0 disk

├─sda1   8:1    0    1M  0 part

├─sda2   8:2    0  200G  0 part /

├─sda3   8:3    0    5G  0 part /boot

├─sda4   8:4    0    6G  0 part \[SWAP\]

└─sda5   8:5    0  289G  0 part /home

sr0     11:0    1 1024M  0 rom

root@osboxes:/home/dima#
```
далее находим UUID для нужного диска посредством команды

Смотрим все разделы файловой системы.
```
sudo blkid
```
Создадим каталоги для монтирования
```
sudo mkdir /mnt/С /mnt/D
```
Открываем от имени администратора файл `/etc/fstab`, содержащий информацию о всех монтируемых при загрузке разделах:
```
sudo vim /etc/fstab
```
Добавляем в конец файла,

для NTFS:
```
UUID="7ECCC7F5CCC7A62D" /mnt/Shared ntfs rw,nls=utf8,gid=plugdev,umask=0002 0 0
```
для FAT и FAT32:
```
UUID="355B-FE37" /mnt/TrendNet8Gb vfat rw,exec,codepage=866,nls=utf8,gid=plugdev,umask=0002,nofail,users 0 0
```
Монтируем только что вписанные разделы диска:
```
sudo mount -a
```
## Расширения дискового пространтсва

Возникли сложности с расширением

![](images/image318.png)пришлось делать так.

![](images/image113.png)
```
.\\VBoxManage.exe clonehd "F:\\Master\\VirtialMachine\\cent8\\cent8.vdi" "F:\\Master\\VirtialMachine\\cent8\\cent82.vdi"  --format VDI

 .\\VBoxManage.exe modifyhd  "F:\\Master\\VirtialMachine\\cent8\\cent82.vdi"  --resize 40999
```

# VM Ware

## mount 

If automount doesn't work.. I had it. But there is a solution

check that mount works
```
sudo mkdir -p /mnt/hgfs/
sudo /usr/bin/vmhgfs-fuse .host:/ /mnt/hgfs/ -o subtype=vmhgfs-fuse,allow_other
```

after that add this to `/etc/fstab`
```
vmhgfs-fuse   /mnt/hgfs    fuse    defaults,allow_other    0    0
```


# Операции с пользователями

Команда позволяет запустить shell другого пользователя
```
su - username 
```

Рекомендуется всегда писать `-`

![Linux su Commands1](images/image303.png)

Зайти под root
```
su -
```

Рекомендуется всегда писать `-` ,

Когда закончили работать из под root , можно существует команда `exit`, которая выходит из под рута к обычному пользователю

![](images/image116.png)

Показывает имя пользователя
```
whoami
``` 

![](images/image441.png)

Выполнять команды администратора рекомендуется не заходя в сессию root , а исполняя команды через `sudo`.

Политика использования sudo определяется в файле `/etc/sudoerr` и сприптами в каталоге `/etc/sudoerr.d`. Рекомендуется явно не редактировать эти файлы, а использовать утилиту `visudo`

**ВАЖНО**. Иногда не видно, что в `sudoerrs` и через `visudo` пользователю установлена группа `wheel` или явно прописано что для пользователя разрешены все права. Запросто может быть скрипт в каталоге `/etc/sudoers.d` где будет одна строчка. Например:

![](images/image442.png)

Важные секции в файле:

для группы `wheel` разрешены все команды (для RedHat) для группы `adm` в Ubuntu

![](images/image253.png)

есть и опасная строчка, можно разрешить группе исполнять все права без ввода пароля. По-умолчанию она закоментирована

![](images/image179.png)

Вот-так выдадим права пользователю исполнять команды добавления пользователя и смены пароля со всех компьютеров

![](images/image250.png)

`who` Показывает кто залогинен в системе

![](images/image21.png)

`w` Показывает кто сейчас залогинен  в системе и что он делает

![](images/image54.png)

`id` Показывает user id, primary group id, и лист групп, в которых находится пользователь

![](images/image340.png)

у пользователя видно, что группы суперпользователя у юзера нет (wheel).

`usermod` Меняет существующие атрибуты пользователя

изменение имени
```
usermod -c 'newName' oldName   
```

```
usermod -c 'jhonny' john  
```

![](images/image247.png)

добавить пользователя student в группу wheel 
```
usermod -aG wheel student 
```

![](images/image299.png)

для того, чтобы изменения увидел сам пользователь, пользователю необходимо войти заново в систему!!

# Операции с правами

## File Permission

Все файлы в Linux имеют три типа permissions: чтение, запись, запуск. Также permissions бывают трех типов: для владельца, для группы владельцев, и всех остальных пользователей. Можно увидеть исполнив команду `ls -l`

```
 drwxr-xr-x 2 username username       4.0K 2009-08-13 10:16 docs  
 -rw-r--r-- 1 username username       8.1K 2009-07-09 16:23 roster.py  
 lrwxrwxrwx 2 username username       4.0K 2009-08-13 10:16 team.docs 
```

Тут видим `-d` директория `-l` symbolic link. Далее разрешения для владельца, для группы владельцев и всех остальных

Изменить владельца, группу владельцев у файла.
```
chown user \[:group\] file  
```

Изменяем владельца на anna и группу profs
```
chown anna:profs file  
```

Если хотим поменять только группу владельцев.
```
chgrp group\_name file\_name
```

![](images/image56.png)

`chmod` Используется в двух режимах.
* Абсолютный: 
  ```
  chmod 750 my_file
  ```

  Права доступа представляют собой три восьмеричных числа.
  ```
  chmod 755 my_script
  ```
  ![](images/image336.png)

* Относительный:  
  ```
  chmod +x my_script Устанавливаем права на запуск
  ```
  
  В этом режиме права доступа задаются так `chmod group operator permission`. Если group не указываем считается, что имеем ввиду пользователя владельца

  ![](images/image286.png)

  ![](images/image190.png)


## umask

Начальные права доступа для файла `666`, для директории `777`. Понятие `umask` это тоже 3 цифры, которые отнимаются от начальных прав доступа. Если поставим `umask 022`. При создании новых файлов права доступа будут 644, для директорий 755.Задается для всех пользователей в файле `/etc/profile`. Для конкретного пользователя можно поменять в `~/.bash_profile`

Также можно поставить для текущей сессии через 
```
umask value
```

## Специальные права доступа

Существуют три специальных права доступа: 
* SUID (Set User id)  

  ![](images/image117.png)

  Для установку SUID
  ```
  chmod 4770 your\_file 
  или 
  chmod u+s your\_file
  ```
  Это очень вредная и опасная штука. При установке права доступа SUID любой пользователь будет запускать файл как владелец этого файла. Обычно такие файлы подкрашиваются красным, чтобы отобразить, что операции могут быть крайне опасными.

  ![](images/image424.png)

  какие файлы в нашей имеют права доступа SUID

  find / -perm /4000 2>/dev/null

* SGID(Set group id)

  Для установки 
  ```
  chmod 2770 your\_directory  или    chmod g+s your\_directory
  ```
  Удобно использовать, когда необходимо чтобы файлы создаваемые в директории членом группы устанавливали группу не пользователя, а определенную.

  Пример:

  1. Создадим директори profs в каталоге /tmp из под root. Далее изменим group owner на profs. И выдадим 770 права для группы. Цель в том, что дать права пользователям profs заходить в директорию  создавать там файлы

  ![](images/image272.png)

  2. Убедимся, что в группу profs входят два пользователя.

  ![](images/image319.png)

  3. Залогинемся под anna и создадим файл в директории profs

  ![](images/image244.png)

  Увидим, что группа прописалась как anna , т.к primary группа у пользователя anna это anna. Для того, чтобы дать права на запись другим членам группы profs, необходимо менять через chown для этого файла группу. И для всех последующих файлов, создаваемых пользователем anna. НО есть другой способ.

  ![](images/image66.png)

  Теперь в группе прав доступа для группы появилась буква s, что значит SGID право доступа. Теперь при создании новых файлов, группа у файлов будет проставляться такой же как и у директории.

  ![](images/image257.png)

  это значит, что все пользователя группы profs теперь имеют доступ на чтение и запись в файлы, создаваемые anna.

* Sticky bit 
  Для установки
  ```
   chmod 1770 your\_directory или chmod +t your\_directory
  ```
  Создает право доступа на удаление файла только для его владельца и для владельца директории.

  Увидим, что пользователь audrey входит в группу profs и имеет права на запись(т.е и на удаление) файлов в директории /tmp/profs

  ![](images/image176.png)

  ![](images/image374.png)

  зайдем в директорию и удалим файл, созданный пользователем anna

  ![](images/image410.png)

  Иногда может быть полезным ограничение на удаление только теми пользователями, которые непосредственно создавали файл.

  ![](images/image228.png)

## ACL (Access Control List)

Для более расширенного управления правами доступа применяются ACL. Например, файл может принадлежать сразу нескольким группам пользователей, с различными правами доступа.

Есть два вида ACL

* normal ACL. Правила ACL применяются к уже существующим файлам и директориям. К новым файлам и директориям правила не применяются
* default ACL. Применяются ко всем новым файла и директориям.

Рекомендовано сразу устанавливать ACL к новой директории.

Получить информацию о ACL у файла или директории

```
getfacl file_or_directory 
```

Установить правило
```
setfacl -R -m g:name\_of\_group:permissona directory
```

`-R`  флаг рекурсивности по всем файлам внутри директории

`-m` modified

`-g` группа

Установить правило (default ACL). Как сказано выше, это правило будет применяться для всех новых файлов внутри директории

```
setfacl -m d:g:name\_of\_group:permissona directory 
```
Пример:

Создадим две группы accounts и sales. Далее создадим директории accounts

![](images/image367.png)

ПРОБЛЕМА. Как без изменения прав доступа others дать права группе accounts на чтение файлов в директории sales?

Получим данные acl. Видим, что информация предоставляется даже если никаких правил ACL еще не было установлено.

![](images/image204.png)
```
setfacl -m d:g:accounts:rx sales
```
Применили default ACL , т.к никаких файлов в директории нет. Видим, что добавился + рядом с правами доступа к директории sales

![](images/image332.png)

![](images/image40.png)

Создадим файл внутри директории и убедимся, что правило ACL применилось.

![](images/image143.png)

Видим сообще о реально действующих правах доступа. Даже если в правилах ACL мы указывали rx для группы accounts. Реально работать будет только x из-за политики Lunix, которая запрещает делать файлы запускаемыми по-умолчанию.

Создадим директорию 2020 внутри sales. А также еще одну директорию внутри 2020 и увидим, что правила ACL наследуются рекурсивно.

![](images/image290.png)

![](images/image136.png)

## Примеры сложностей понимания прав доступа

### Удаление файла

создадим в каталоге `/home/anna` файл из под root

![](images/image128.png)

Может ли anna удалить этот файл? С одной точки зрения нет, т.к она не является владельцем файле, не входит в группу root. А для всех остальных описано право доступа только на чтение.

НО можно. Почему. Да потому, что на папке `/home/anna` установлены следующие права. Видим что anna является владельцем и у не владельца есть права на запись, значит и на удаление.

![](images/image371.png)

### Запись в файл

создадим в каталоге `/home/anna` файл из под root

![](images/image128.png)

Может ли anna записать в этот файл? Ответ нет. Но бывают странные случаи.

Откроем vim и попытаемся отредактировать файл.

![](images/image236.png)

Vim предупреждает нас, что файл только для редактирования. Но мы все равно продолжим, поменяем файл и выйдем `:wq!`

![](images/image402.png)

Vim удалил старый файл и создал новый от имени anna.

### Смена прав доступа

создадим файл new_file из под root в `/home/anna`

Сменим владельца и группу на `anna`. Затем поставим права доступа `006`.

![](images/image167.png)

Может ли анна посмотреть этот файл? Нет. Т.к у владельца нету прав доступа на чтение.

НО т .к anna является владельцем файла она может изменять права доступа.

![](images/image358.png)


# Свойства пользователя

У каждого поля есть обязательные свойства. Рассмотрим на примере свойств описанных в `/etc/passwd`

![](images/image219.png)

* имя пользователя
* пароль. В файле passwd он указан как x, который на самом деле placeholder. Пароли хранятся в зашифрованном виде в shadow-файлах
* UID. Уникальный ID пользователя
* Group ID. ID группы пользователя. Каждый пользователь должен быть членом хотя бы одной группы. При создании пользователя автоматически создается группа с именем пользователя. Т.е он всегда будет находится минимум в одной группе - с тем же названием, что и имя пользователя.
* GECOS. Дополнительная информация в виде строки, не обязательное свойство
* Домашная директория. По-умолчанию пользователь может создавать файлы только в домашней директории и каталоге /tmp
* Shell. Дефолтный shell, который запускаетс при входе пользователя.

Добавить пользователя 

```
useradd -m userName  
```

![](images/image323.png)

`-m` создать домашнюю директорию

`-d` задать имя домашней директории

`-с` установить комментарий к пользователю (GECOS)

`-s` указать shell для пользователя

Посмотреть дефолтовые значения, с которыми создаются пользователи. Они располагаются в файле `/etc/defaults/useradd`
```
useradd -D 
```

![](images/image411.png)

а также в файле `/etc/login.defs` В нем настройки длительности действия пароля, минимальное кол-во символов в пароле, диапазоны id системных и персональных пользователей, метод шифования паролей.

![](images/image237.png)

![](images/image130.png)


удалить пользователя
```
userdel -r userName  
```

![](images/image184.png)

сменить текущий пароль текущего юзера
```
passwd   
```

из под root можно менять пароль любого юзера
```
passwd userName   
```

заблокировать пользователя
```
passwd -l userName   
```

также можно это сделать командой 
```
usermod -L userName  
```

при этом в файле с хешами паролей появится ! знак перед хешом.

разблокировать пользователя
```
passwd -u userName   

или usermod -U userName
```

При этом знак ! перед паролей удалится. Можно это и руками делать, но считается плохой практикой.

В каталоге `/etc/skel/` содержат дефолтный скрытые файлы. Когда добавляем пользователя через `useradd -m option`, `/etc/skel/` копируется в домашнюю директорию пользователя

![](images/image94.png)

Пароли хранятся в зашифрованном виде в `/etc/shadow`

![](images/image104.png)

Колонки:

* имя пользователя
* хеш пароля
* время начала действия пароля в днях с 1970 года
* минимальное кол-во дней действия пароля
* максимальное кол-во дней действия пароля
* период в течении которого пользователю будет выдаваться предупреждения о скором истечении срока действия пароля.

Группы пользователей хранятся в файле `/etc/group`

В ней указаны имя группы, id группы и список пользователей, входящих в группу. В `/etc/passwd` также указывается id группы, но там так называемые primary group. В `etc/group` secondary группы

![](images/image315.png).

## Операции с группами

Создание новой группы
```
groupadd name_group 
```

Модификация группы (используется редко)
```
groupmod name_group 
```

Удаление группы
```
groupdel name_group 
```

Показать всех пользователей входящих в группу
```
lid -g name_group 
```

# Сеть

Показать список сетевых интерфейсов и их сетевые адреса
```
ip addr show 
```

ранее эту информацию обычно получали через `ifconfig`

![](images/image426.png)

Показать список сетевых интерфейсов
```
ip link 
```

![](images/image437.png)

похожая команда, но со статистикой по сетевым интерфейсам 
```
ip -s link show
```
![](images/image293.png)

Добавить еще один ip на сетевой интерфейс
```
ip addr add dev name\_of\_interface ip\_with\_submask 
```

![](images/image305.png)

Показать список роутеров (gataways)
```
ip route show 
```
![](images/image85.png)

Удалить шлюз
```
ip route del default via 192.168.100.1 
```

Добавить шлюз
```
ip route add default via 192.168.100.1 
```

![](images/image320.png)

Посмотреть dns сервер
```
cat /etc/resolv.conf 
```

![](images/image376.png)

Этот файл автоматически создается NetworkManager при перезагрузке.

## NMCLI (Network Manager command line interface)

Утилита для конфигурации сетевых интерфейсов.

Для работы с этой утилитой необходимо проверить несколько вещей:

1. Проверка статуса запуска NetworkManager
```
systemctl status NetworkManager
```

![](images/image404.png)

2. проверка наличия пакета bash-completion
```
Arpm -qa | grep bash-completion
```

![](images/image445.png)

### Создание новой конфигурации подключения

Тут нужно пользоваться частым TAB, т.к команды длинные

```
nmcli connection add ipv4.addresses 192.168.100.11/24 ipv4.gateway 192.168.100.1 ipv4.dns 8.8.8.8 type ethernet ifname enp0s3
```

![](images/image383.png)

посмотреть список соединений
```
nmcli connection show 
```

![](images/image105.png)

видим, что новое соединение не активно.

сделать соединение активным
```
nmcli connection up name_connection 
```

![](images/image238.png)

## nmtui (Network Manager text user interface)

Более легковесная утилита чем nmcli для конфигурации сетевых подключений.Запускается из консоли.

![](images/image146.png)

## Расположение файлов конфигураций сетевых интфейсов

Network Manager сервис отвечает за создание и модификацию конфигурация для сетевых интерфейсов. В RHEL 8 они располагаются в `/etc/sysconfig/network-scripts`

![](images/image388.png)

В них стоит смотреть, если конфигурация сетевых интерфейсов через `nmcli` и `nmtui` завершилась неудачно. После измененения конфигурация для их применения нужно выполнить nmcli connection up name_connection, либо перезагрузить систему, либо перестартовать networkmanager

![](images/image321.png)

![](images/image206.png)

## Проверка сетевого соединения

самая простая команда для проверки соединения
```
ping url 
```

![](images/image50.png)

Прервать команду можно через `Ctrl + C`

Иногда использовать в скриптах, строгое числов пингов 
```
ping -c 1 google.com
```

Также иногда полезна опция `ping -f google.com`. Отправляет так много пакетов как может и далее показывает статистику. Удобно для проверки сети.

Описание выше `ip addr show`, `ip route show`

команда для проверки dns
```
dig url 
```

![](images/image193.png)

# Управление процессами

Любую команду, которую запускаем из shell будем называть job.

запустить command в фоновом режиме
```
command & 
```

Если предыдущая джоба запускалась не в фоновом режиме. Можно ее остановиться через `Ctrl + Z` и затем написать `bg` для запуска в фоновом режиме.

Чтобы посмотреть джобы используем команду `jobs`

![](images/image353.png)

Также джобу можно перевести из фонового режима в активный командой `fg N`, где N - номер джобы в списке джобов

Посмотреть все процессы. Возможны два стиля, без дефиса это BSD стиль, с дефисом это System5 стиль. Пошло с середины 70-x, т.к было две разных UNIX системы.

```
ps aux
```

![](images/image13.png)

Тут колонки. 
* PID - process ID(id процесса) 
* утилизация процессора, 
* утилизация памяти, 
* утилизация виртуальной памяти, 
* остаток памяти, 
* tty терминал, в котором запустился процесс, если ? то это значит процесс в фоновом режиме. 
* статус. 
* Дата старта
*  время работы процесса. 
*  команда, ассоциированная с процессом.

Процесс с PID это systemd.

Процессы с командой в квадратных скобках это процессы ядра.

Процессы отсортированы по времени старта. Т.е самые новые процессы будут внизу,  в том числе и сам ps aux.

![](images/image275.png)

Процессы в иерархии. Показывает отношения между родительским и дочерними процессами. Тут есть фишка. Если остановить родительский процесс, все его дочерние также остановятся.
```
ps -fax 
```

![](images/image96.png)

Посмотреть процессы пользователя
```
ps -fU user 
```

Посмотреть дерево определенного процесса
```
ps -f --forest -C process 
```

![](images/image8.png)

Посмотреть возможные спецификаторы процессов. Им около 200 штук
```
ps -L 
```

Зная эти спецификаторы, можно отображать только определенные свойства процессов командой `ps -eo спецификатор`

Например, отобразим команду и id процесса

```
ps -eo pid, cmd
```

![](images/image443.png)

## Сигналы

Страница помощи по сигналам 
```
man 7 signal
```

![](images/image249.png)

Остановить процесс можно через `kill pid` , а также через `k` из команды `top`, а также

```
pkill name
```

```
killall name
```

## Приоритеты

Тот процесс, который приоритетнее получает больше процессорного времени. Приоритет изменяется от самого высокого -20 до самого низкого 19.

Еще выше процессы ядра с приоритетом rt (runtime)

Через `top` командой `r`, можно поменять приоритет у процесса.

Тут важно помнить, что указываем приращение к текущему приоритету. -20, будет означать вычесть из текущего приорита 20 . Если был приоритет 20, он танет 0, т.е приоритет повысится. На картинке видны одинаковые процессы, но у одного приоритет 0 и он загружает почти весь процессор. Если приоритеты одинаковые процессу будут получить одинаковое время процессора.

![](images/image86.png)

А также
```
renice -n value pid 
```
где после `n` указывается приращение приоритета.

Можно запустить процесс уже с приоритетом 
```
nice -n value command
```

## Профилирование системы

Сервис `tuned` призван применять к системе различные профили производительности.

Показать список профилей
```
tuned-adm list 
```

![](images/image243.png)

Показать активный профиль (list его тоже отображает)
```
tuned-adm active 
```

![](images/image378.png)

Активировать профиль
```
tuned-adm profile name_profile 
```

![](images/image155.png)

# Установка пакетов RPM(Red Hat Package Manager)

В состав пакета rpm входит сжатые файлы сpio, метаданные, а также список зависимостей пакета. Пакет также может содержать и скрипты.

Для установки пакетов используются репозитории. Можно поставить пакет и самостоятельно, но это не рекомендуется, т.к в этом случае не будут проверены зависимости пакета. При установке из репозитория зависимости обязательно проверяются. В RHEL 8 введены разделены репозитории на два типа. Application stream (appstream) для пакетов приложений и baseOS для пакетов операционной системы.

Путь к репозитории в RHEL добавляются как файл в каталог `/etc/yum.repos.d`

![](images/image432.png)

Показать список подключенных репозиториев
```
yum repolist 
```

![](images/image49.png)

AppStrem делится на два типа составляющих: стандартные rpm пакеты и модули. Модули содержат streams (версии) для возможности иметь несколько версий приложений. Модули также содержат профили (profiles) Профиль это список пакетов для определенных целей, например minimal, default, extended. Модуль может ссылаться на пакеты, которые не находятся непосредственно в каком-то из его stream.

## Пакеты

Поиск пакета в репозиториях
```
yum search name 
```

![](images/image362.png)

Более глубокий поиск. Поддерживает паттерны и ищет по файлам внутри пакетов и в их описаниях
```
yum provides name 
```

Установить пакет
```
yum install name 
```

![](images/image145.png)

Удалить пакет
```
yum remove name 
```

Пакеты могут быть защищены от удаления, например при удалении vi будет выведено сообщение, что пакет защищен.

Обновить пакет и его зависимости. Если не указываем name значит обновляем все пакеты.
```
yum update name 
```

Детальная информаци о пакете
```
yum info name 
```

![](images/image355.png)

Список пакетов
```
yum list all, installed 
```
  
Понять в каком пакете находился тот или иной файл  
```
rpm -qf file_name 
```
например

```
rpm -qf /etc/tcsd.conf.
```

Видим некий конфиг. Получаем информацию из какого пакета он установлен. Потом смотрим на список файлов в пакете. Потом можем запросить инфо о пакете.

![](images/image37.png)

Список файлов в пакете
```
rpm -ql name
```

Список конфигурационных файлов в пакете
```
rpm -qс name
```

Список файлов документации в пакете
```
rpm -qd name
```

Показать содержимое скриптов в пакете
```
rpm -qp --scripts name
```

НО команды выше работают только с уже установленными пакетами. Часто бывает нужно понять, а что внутри пакета, который хотим установить, возможно там какие-то скрипты, которые нарушат работу системы, т.к установка происходит под права root.

В этом случае делаем так. Если пакета еще нет под рукой, но он есть в репозитории его можно загрузить.

Если установить пакет `dnf-utils`. Устанавливается утилита `yumdownloader`, которой можно выкачивать пакеты из репозитория без установки пакетов.

Когда пакет загружен. Добавляем опцию `p` в команду. Например

Посмотреть список файла в пакете, где name путь до пакета
```
rpm -qpl name\_of\_package 
```

![](images/image403.png)

## Модули

Список модулей
```
yum module list 
```

![](images/image3.png)

Поиск модуля, который содержит пакет
```
yum module provides name
```

Информация о модуле
```
yum module info name
```

Поиск профилей
```
yum module info --profile name
```

![](images/image382.png)

Отображение stream внутри модуля
```
yum module list name
```

![](images/image316.png)

Установить модуль
```
yum module install php:7.2 
```

или 
```
yum install @php:7.2 
```

Установить профиль
```
yum module install php:7.2/devel
```

Стрим (т.е версия) может быть активным или нет. Для активизации версии

```
yum module enable php:7.2
```

При установке новой версии. Предыдущий установленный стрим становиться disable.

## Группы

Это наборы ПО, т.е наборы модулей, пакетов.

Отображение списка групп
```
yum groups list 
```

Отображение полного списка групп. Java отображатся тут
```
yum groups list hidden 
```

Отображение информации о группе
```
yum groups info groupname 
```

Установка группы
```
yum groups install groupname 
```

## История изменений

Отображение списка групп
```
yum history 
```

![](images/image373.png)

Отмена изменений из истории
```
yum history undo number 
```

# Systemd

Всем после загрузки ядра управляет systemd. Обьекты управления называются unitами. (mount файловых систем, устройств, старт сервисов и тд)

Для работы с systemd используется команда `systemctl`

Показать список типов юнитов управления.
```
systemctl-t help . 
```

![](images/image17.png)

Показать список юнитов и их статус
```
systemctl list-unit-files . 
```

![](images/image100.png)

Показать список запущенных юнитов
```
systemctl list-units . 
```

![](images/image407.png)

У сервиса есть статуcы `disabled/enabled`. Показывает будет ли запущен сервис автоматически после перезагрузки

Также `start / stop`. Запущен ли сервис или остановлен в данный момент.

Установим сервис: 
```
sudo yum install vsftpd
```

Показать статус сервиса
```
systemctl status name\_of\_service . 
```

![](images/image57.png)

видим распложение конфигурации сервиса, также статус `disabled`, означающий то, что сервис не будет включен автоматически после перезагрузки. Также `vendor preset` - статус от автора пакета, в данном случае `disabled`

```
systemctl start name\_of\_service . Запустить сервис
```

![](images/image365.png)

Видим, что сервис в статусе `active`, т.е он сейчас работает. Но в тоже время он в статусе `disabled`, т.е не будет стартован после перезагрузки. Также видим PID

Запускать сервис после перезагрузки
```
systemctl enable name\_of\_service . 
```

![](images/image455.png)

Также можно активировать и одновременно сделать сервис enabled
```
systemctl enable --now name\_of\_service
```

## Конфигурация юнитов

`/etc/lib/systemd/system` Файл с системными юнитами. Не рекомендуется трогать

`/etc/systemd/system` Файл с прикладными юнитами.

`/run/systemd` Файл с runtime-юнитами

Если необходимо сконфигурировать юнит, рекомендуется создавать кастомный `/etc/systemd/system` либо использовать утилиты

```
systemctl edit unit.service
```

показать настройки сервиса
```
systemctl cat unit.service 
```

![](images/image453.png)

показать список возможных параметров для конкретного сервиса. Список большой.
```
systemctl show unit.service 
```

![](images/image309.png)

### пример модификации конфигурации

входим в режим редактирования конфигурации. При этом создается файл в каталоге `/etc/systemd/system`
```
systemctl edit vsftpd
```

Далее откроется редактор nano, куда введем следующие настройки. Они позволяют всегда перезапускать сервис через 5 секунд, если он по каким-то причина остановился

![](images/image268.png)

Сохраним файл. Далее необходимо выполнить команду
Для применения изменений в конфигурациях. Далее рестартанем сервис
```
systemctl daemon-reload
```

![](images/image44.png)

Далее убьем сервис. И увидим, что он стартует через 5 секунд.

![](images/image295.png)

Статья о том, как сделать из запускаемого jar -сервис

[https://dzone.com/articles/run-your-java-application-as-a-service-on-ubuntu](https://www.google.com/url?q=https://dzone.com/articles/run-your-java-application-as-a-service-on-ubuntu&sa=D&source=editors&ust=1662229049598142&usg=AOvVaw2xB2e_agiloAjHlMPVEsVQ)

О том как сделать Kafka сервисом

[https://www.digitalocean.com/community/tutorials/how-to-install-apache-kafka-on-ubuntu-18-04-ru](https://www.google.com/url?q=https://www.digitalocean.com/community/tutorials/how-to-install-apache-kafka-on-ubuntu-18-04-ru&sa=D&source=editors&ust=1662229049598691&usg=AOvVaw3J-7nghLhuCieocOYUQy3v)

# Логирование

![](images/image391.png)

`Rsyslogd` сервис логирования, которые существует уже очень долгое время. Обычно логи записываются в каталог `/var/log`, но можно настроить и другое расположение.

Так как `rsyslogd` является сервисом, его можно запускать и останавливать.

Начиная с RHEL7 появился systemd, который отвечает за управление сервисами. Вместе с ним появился сервис логирования `journald`, целью которого является сбор информации со всех сервисов systemd, теперь сервис `journald` стоит в самом центре логирования системы. Управление осуществляется с помощью команды `journalctl`

По-умолчнанию `journald` неперсистентен. Но к счастью, существует спец файл `/dev/log`, который перенаправляет информацию на `rsyslogd`

Если этого перенаправления недостаточно, можно сделать `journald` персистентным, создав директорию  `/var/log/journal`. Далее рестартовать сервис `journald` или перезагрузить систему.

## Rsyslogd

Убедиться, что сервис запущен
```
systemctl status rsyslog.service 
```

![](images/image279.png)

Конфигурационный файл в `/etc/syslog.conf`

Вспомогательные файлы настроек в директории `/etc/rsyslog.d`

Каждая строчка конфигурации имеет три свойства:

1. Facility. Цель лога. Придумана в середине 70-x и поэтому список facllity не расширяется. Пример: kern, authpriv, cron

Для сервисов, которые не имеют собственных facility существуют faclility начинающиеся с local с постфиксом от 0 до 7. В конфигурациях сервиса можно указать в какой local facility будет писать сервис. Но из-за проблемы ограничения facility многие сервисы имеют свои правила логирования и не используют rsyslog

2.  Severity. Уровень логирования. Пишется через точку после Facility
3.  Destination. Куда будет записан лог. Обычно запись лога происходит в каталог /var/log/

Для записи используется команда logger

## systemd-journald

Используется также при команде `systemctl status unit` После статуса показываются несколько последних строк, которые записал unit в journald.

![](images/image311.png)

`journalctl` используется для получения информации о событиях лога. Если запустить без аргументов, отобразяться все событии с момента запуска системы.

посмотреть логи определенного юнита
```
journalctl UNIT=name\_of\_unit 
```

Обратить внимание, что список опций можно как обычно получить через TAB, а также что опции задаются с большой буквы

![](images/image53.png)

Конфигурационный файл в `/etc/systemd/journald.conf`

Для персистентности лога необходимо выполнить 
```
mkdir /var/log/journal
```

Будут создаваться файлы логов, НО эти файлы будут в бинарном формате, т.е их нельзя будет прочитать с помощью редакторов, только через `journalctl`

По-умолчанию записанные логи в `/run/log/journal` удаляются после перезагрузки системы. Для того, чтобы отключить удаление, необходимо в  `/etc/systemd/journald.conf` поменять переменную Storage.

`persistent`: хранить логи в `/var/log/journal`, если ее не существует создавать

`volatile` : хранить логи только в `/run/log/journal`

`auto`: хранить логи в `/var/log/journal` иначе, если ее ее не существует в `/run/log/journal`

По-умолчанию ротация логов настроена на месяц, а также настроены правила. Логи не могут занимать более 10% места в файловой системе, проверяется, что минимум 15% свободного места остается в системе. Эти настройки также можно изменить в конфигурационном файле.Текущее состояние этих ограничений, можно посмотреть через 

```
systemctl status systemd-journald.service
```

![](images/image173.png)

## logrotate

Запускается cron daily

Конфигурационный файл в `/etc/logrotate.conf`

![](images/image11.png)

Вспомогательные файлы настроек в директории `/etc/logrotate.d`

![](images/image409.png)

Пример

![](images/image285.png)

## /proc и ядро

В `/proc` присоединена файловая система, где каждый процесс предстален как директория с PID, а также есть файлы состояний.

![](images/image39.png)

Например `meminfo`.

Можно наблюдать за его изменением: 
```
watch cat meminfo
```

![](images/image368.png)


`sysctl -a` выводим множественные настройки системы. Их можно поменять указав строчку в файле `/etc/sysctl.conf`

![](images/image205.png)

Правильным считается создание отдельного файла в директории `/etc/sysctl.d`

А для настроек пользователей существует спец. каталог `/usr/lib/sysctl.d`

![](images/image112.png)

Обновление ядра происходит всегда с сохранением старого ядра для того, чтобы иметь возможность откатиться на старое ядро. Например проприетарный драйвер может зависеть от версии ядра и при обновлении ядра драйвер, а следовательно и устройство, перестанет корректно работать.

```
yum update kernel
```
или 

```
yum install kernel
```

## Загрузка (boot)

![](images/image397.png)

После запуска компьютера Power-on Self Test. Самопроверка оборудования на корректность работы. Далее BIOS или UEFI, потом загрузчик GRUB, далее ядро с `initramfs` - временная файловая система с временной директорией и набором драйверов. После старта ядра стартует `systemd`, который и управляет всем. Далее `base-os` это устройства , далее сервисы.

В момент grub загрузчика можно нажать `с` далее попадаем в command mode.

В меню видим несколько вариантов

![](images/image180.png)

`help` выводит доступные команды

`ESC` выходим обратно в меню GRUB.

![](images/image248.png)

`Resque` режим загрузки с ограниченной функциональностью. Но цель этого режима запустить систему, если присутствуют неполадки.

`e` входим в расширенное меню GRUB

![](images/image80.png)

Первые строчки о загрузке видео-драйвера. Далее строки с расположением ядра. `crashkernel` расположение для файла дампа загрузки, если все падает его отправляем в RHEL support. Далее опция, которую можно убрать rhgb quiet - после этого при старте отображаются более детальные логи старта.

Файл конфигураций постоянных настроек GRUB `/etc/default/grub`

После изменений конфигураций для их применения, необходимо выполнить команду в зависимости от типа загрузчика (для проверки `mount | grep efi`):

для BIOS: 
```
grub2-mkconfig -o /boot/grub2/grub.cfg
```

для UEFI: 
```
grub2-mkconfig -o /boot/efi/EFI/redhat/grub.cfg
```

![](images/image196.png)

![](images/image220.png)

![](images/image198.png)

Для интереса посмотрим что же это за файл, который получается после генерации

![](images/image28.png)

![](images/image405.png)

## systemd target

Это набор юнитов. Некоторые из них isolatable, т.е финальные после старта системы.

`emergency.target` Содержит минимальный набор сервисов на случае аварии системы

`resсue.target` Также на случай аварии, но с более расширенным составом сервисов. Рекомендуется загружаться с помощью этого тартета в случае проблем, а уже потом,  если не получается загружаться в `emergency target`

`multi-user.target` Режим без пользовательского интерфейса

`graphical.target` Режим с графическим интерфейсом

Юниты как и прочие активизируеются через `systemctl`

Выключим любой из сервисов

![](images/image259.png)

Увидим упоминание `multi-user.target`

![](images/image70.png)

Посмотрим в настройки сервиса httpd. 
```
systemctl cat httpd
```

![](images/image458.png)

Видим секцию install с упоминанием таргета. Т.е минимальный режим, в котором запускается этот сервис это mult-user.target.

Посмотреть настройки режима 
```
systemctl cat multi-user.target
```

![](images/image14.png)

![](images/image223.png)

Тут не видим конкретных сервисов, которые стартуют в этом режиме. Тольки видим зависимость от `basic.target`. А также, что запускается этот юнит после `resque.target`

Директория `/etc/systemd/system`

вот тут и увидим список сервисов для всех target
![](images/image421.png)

![](images/image140.png)

А также команда 
```
systemctl list-dependencies
```

Показывает режимы и их зависимости от сервисов

![](images/image255.png)

Вывести текущий таргет по-умолчанию
```
systemctl get-default 
```

![](images/image448.png)

Установить текущий таргет по-умолчанию
```
systemctl set-default  target_name 
```

![](images/image18.png)

После перезагрузки стартуем без графического интерфейса.

![](images/image138.png)

далее можем стартануть юнит графического таргета
```
systemctl start graphical.target
```

При загрузке системы в Grub меню можем нажать `e` и указать необходимый target для загрузки

![](images/image361.png)

Перейти из любого таргета в любой можно командой
```
systemctl isolate target
```

![](images/image264.png)

## Проблемы при загрузке

![](images/image326.png)

### Восстановление пароля root.

При старте системы, нажимаем `e`, входим в режим, где можно указать параметры старта

![](images/image366.png)

Необходимо найти строчку в аргументах запуска где упоминается ядро вставить в аргументы загрузки фразу `rd.break`

![](images/image106.png)

![](images/image181.png)

далее

Если введем `mount` увидим небольшое число точек монтирования, в том числе и `cl-root`. Оно имеет доступ только на read. Нужно поменять права на `rw`
```
mount -o remount,rw /sysroot
```

![](images/image114.png)

теперь если выполним опять `mount` увидим, что права поменялись

![](images/image35.png)

Если выполним `ls` увидим довольно необычную структуру директорий потому, что мы находимся в `initramfs`, которая доступна только в момент запуска.

![](images/image343.png)

Настоящая корневая папка root системы находится в `sysroot`, там же лежит и файл `/etc/passwd`. Для того, что сделать изменения в этом файле, выполним команду, которая изменит текущее расплоложение root директории
```
chroot /sysroot
```

![](images/image239.png)

```
echo password | passwd --stdin root
```
Вообще так делать не надо, ибо тут берется пароль из stdin и команда останется в истории. Лучше через `passwd root` и так далее.

![](images/image282.png)

```
touch /.autorelabel
```
Некий магический файл, который нужно создать для удовлетворения требований SELinux

![](images/image461.png)

`Ctrl-D`

`Ctrl-D`

Далее последует довольно длительная перезагрузка.

![](images/image352.png)

### Проблемы при mount во время старта

![](images/image266.png)

# Bash Shell scripts

Чтобы запустить скрипт, нужны права на запуск, запускаем так `./my_script`.

При этом скрипт исполняется в subshell, дочерней консоли, т.е в отдельном контексте с точки зрения переменных и директорий, т.е например если делаем `cd` в скрипте, после завершения работы скрипта, смены текущей директории родительского shell не произойдет.

Но если запускаем вот так `. my_script`. это называется source - код скрипта запускается в текущей shell.

## Основные конструкции


### swich

![](images/image460.png)

case регистрозависимый

Перепишем в регистронезавимый вариант

![](images/image278.png)

# SSH

![](images/image149.png)

c помощью утилиты `ssh-keygen` создаем два ключа, закрытый и публичный. Помещам публичный ключ в home папку на сервере. При открытии ssh сессии отправляется публичный ключ, которым сервер шифрует сообщение и отправляет на клиента. Клиент расшифровывает сообщение закрытым ключом и передает сообщение на сервер, если сообщение верное, то сервер разрешает соединение.

1.  Сгенерируем пару ключей. Можно задать пароль для ключа, так будет безопаснее, если ключ будет украден без пароля все равно не подключишься, но это не так удобно как без пароля. ssh-keygen

Создадим ключ с паролем.

![](images/image438.png)

![](images/image420.png)

в каталоге, который можно поменять при создании ключей, лежит закрытый ключ, публичный ключ и файл с хостами.

`ssh-copy-id` удобная утилита для добавления открытых ключей на сервера по ssh

![](images/image20.png)

Можно указать пользователя через `user@host`. Если не указывать юзера будет использовано имя текущего пользователя.

После этого при соединении через ssh на хост будет спрошен пароль.

![](images/image200.png)
Можно сделать так, чтобы пароль вводить только один раз в сессии. Для этого
для аллоцирования памяти содержащей пароль
```
ssh-agent /bin/bash 
```

для установки пароля
```
ssh-add 
```

![](images/image224.png)

После этого в текущей сессии не нужно будет вводить пароля при подключении по ssh

`/etc/ssh/sshd_config`  файл серверных настроек ssh

из важного:

![](images/image213.png) Порт ssh сервера по-умолчанию 22

![](images/image42.png) Узлы с какими ip адресами могут соединяться с сервером по ssh

![](images/image245.png)Возможно зайти под root через ssh. Если сервер открыт всему интернету крайне рекомендуется ставить no.

![](images/image287.png) Список пользователей, под которыми можно заходить по ssh

![](images/image436.png) Возможно ли заходить с паролем. Если выключить будет возможно только по сертификату.

Для применения настроек нужно выполнить.
```
systemctl restart sshd
```

`/etc/ssh/ssh_config`  файл клиентских настроек ssh

## Копирование файлов по сети

### scp

копирование на удаленный сервер
```
scp file1 file2 user@remoteserver:/home/student 
```

![](images/image59.png)

копирование содержимого директории удаленного сервера в текущую директорию
```
scp -r user@remoteserver:/home/student .  
```

![](images/image457.png)

![](images/image22.png)

Если логин по сертификату настроен, то и пароля вводить не нужно.

копировать файл с удаленного сервера в директорию
```
scp user@remoteserver:/etc/hosts /tmp/ 
```

или несколько файлов
```
scp user@server:"file1.txt file2.txt" "~/yourpathtocopy"
```

### sftp

Открыть sftp сессию
```
sftp user@host 
```

![](images/image98.png)

`lpwd` отобразить текущую директорию на сервере инициаторе

![](images/image137.png)

`pwd` отобразить текущую директорию на удаленном сервере

![](images/image188.png)

`cd path` сменить директорию на удаленном сервере

![](images/image79.png)

`lcd path` сменить директорию на сервере инициаторе

![](images/image172.png)

`get path` загрузить файл с удаленном сервера

![](images/image118.png)

`exit` для закрытия sftp сессии

`put path` отправка файла на удаленный сервер

![](images/image9.png)

## Rsync Синхронизация директорий по сети

`rsync` использует `ssh` для синхронизации

### опции:

`-r` синхронизация всей вложенной структуры директорий

`-l` синхронизация symbolic ссылок

`-p` не синхронизировать symbolic ссылки

`-n` (dry-run) не синхронизировать, просто отобразить то, что могло бы быть синхронизировано

`-a` archive-mode будет синхронизировано почти все. Эквивалент `-rlptgoD`

`-A` синзронизация как в `-a` + синхронизация ACL

`-X` синхронизация SELinux контекста

Скопируем файлы из `/etc` в папку на сервере через `scp`

![](images/image60.png)

![](images/image425.png)

Теперь на удаленном сервере создадим новые файлы в `/etc`

![](images/image67.png)![](images/image459.png)

Теперь хотим получить изменения в каталоге `/etc` на первом сервере. Но все файлы копировать не хочется заново, т.к они уже скопированы. Воспользуемся rsync

![](images/image369.png)

При этом копируются только новые файлы.

![](images/image246.png)

# HTTP Server

для понимания темы с SELinux нужно рассмотреть настройки сервиса. Рассмотрим `httpd` он же `Apache Server`.

`/etc/httpd/conf/httpd.conf` файл настроек httpd

![](images/image348.png) Порт для сервеа

`/etc/httpd/conf.d/` каталог для дополнительных настроек httpd

`/var/www/htdocs` расположение документации в html формате

![](images/image207.png)

![](images/image153.png)

# SELinux

Часть ядра написанная RedHat для усовершенствования инструментов безопасности.

![](images/image218.png)

SELinux может быть в состоянии `disabled` и `enabled`. Т.к это состояние указывается на уровне ядра, оно может быть изменено только после перезагрузки. НО в `enabled` режиме есть два подрежима. `Enforsing` - все запрещено, что не разрешено явно в правилах SELinux. `Permissing` - режим для отладки, все разрешено, но осуществляется логирование. Режим `Permissing` рекомендуется включать только в случае возникновения неполадок, когда непонятно почему правила SELinux не разрешают то или иное действие.

`getenforce` показать текущий режим SELinux

![](images/image261.png)

`setenforce` переключить текущий режим SELinux между permissive и enforsing

![](images/image301.png)

![](images/image389.png)

`/etc/sysconfig/selinux` файл конфигурации SELinux. Также можно задать состояние при старте.

![](images/image314.png)

Рекомендуется никогда не ставить состояние `disabled`, если предполагается только временное отключение selinux. Лучше идти через `permissive` mode.

Если все-таки SELinux отключить, то включить его будет возможно только перезагрузки

![](images/image335.png)

## Context label

У каждого обьекта в RHEL имеется context label. Она состоит из:

`user` (user context)

`role` (role specific context)

`type` (признак того, какие операции разрешены с обьектом)

Многие команды через опцию `-Z` показывают свойства контекста обьекта

Типы используются в правилах безопасности , какой source обьект имеет доступ к target обьекту.

Пример: если добавить к команде `ps aux` опцию `Z` , т.е `ps auxZ`, отобразиться информация о процессах а также информация от SELinux.

![](images/image76.png)

Видим context label, состояющую из трех частей: `u - user  r- role t-type`. Важен именно `type`.

Посмотрим, что дает опция Z вместе с командой `ls -ldZ /etc/ssh`

![](images/image307.png)

![](images/image230.png)

Сервис `sshd` имеет доступ к этим файлам только потому, что существуют правило, которое определяет доступ типа `sshd` к обьектам `etc` и к обьектам типа `sshd_key_`

Такой же пример можно привести с httpd

![](images/image177.png)

![](images/image263.png)

Существуют правила доступа типа `httpd_` к обьектам типов `httpd\_sys\_script\_exec\_` и `httpd\_sys\_content_`

![](images/image396.png)

## Boolean

Также в RHEL есть флаги boolean. Показать флаги 
```
getsebool -a
```
![](images/image235.png)

![](images/image74.png)

Видим флаг `httpd\_enable\_homedirs`. Чтобы его поменять
```
sudo setsebool -P httpd\_enable\_homedirs on
```

![](images/image298.png)

![](images/image84.png)

## Изменение context label
```
semanage fcontext
```

`restorecon` Для применения изменений контекста.

Иначе можно создать файл `touch /.autorelabel` в корневой директории файловой системы и перезагрузить сервер.

Пример:

Укажем для httpd новую корневую папку, из которой необходимо отображать html страницу

![](images/image350.png)

![](images/image214.png)

![](images/image165.png)

![](images/image160.png)

![](images/image227.png)

![](images/image36.png)

Видим, что получить доступ не можем. Посмотрим на режиме SELinux

![](images/image102.png)

Тут нужно подумать, что возможно httpd не может получить доступ к файлу index.html из-за отсутствия правила в selinux. Поменяем режим SELinux на permissive, чтобы проверить эту гипотезу.

![](images/image34.png)

![](images/image354.png)

Да, действительно правила не позволяют получить доступ.

![](images/image387.png)

Видим что тип каталога `default`.

Добавим поменяем тип
```
semanage fcontext -a -t httpd\_sys\_content_t “/web(/.*)?”
```
`-a` - добавление

`-t` - тип

![](images/image120.png)

далее применим изменения
```
restorecon -R -v  /web
```
![](images/image225.png)

![](images/image294.png)

![](images/image325.png)

## Чтение лога SELinux

SELinux использует сервис `auditd` для записи в audit log. Текст в audit log непросто понять.

Есть команда `sealert`, которая переводит события из audit log в понятный формат и пишет в `/var/log/messages`

![](images/image142.png)

Выведем события audit.log . Найдем событие связанное с httpd

![](images/image99.png)

указывется `source` и `target context`

Также можем вывести что у нас попало в системное логирование
```
journalctl | grep sealert
```
![](images/image24.png)

В логе видим подсказку как получить детальную информацию о событии

![](images/image359.png)

![](images/image270.png)

`restorecon` используется также для восстановления правил SELinux на директории. Например если скопируем какой-то файл в etc, например из home , его тип будет отличаться от файлов находящихся в `etc. restorecon восстановит правило.

# Firewalling

![](images/image33.png)

Самые низкоуровневые настройки фаервола на уровне системы доступны в `nftables`. Ниже только ядро. В ранних версиях RHEL использовались `iptables` для более понятного конфигурирования правил. Начиная с RHEL 8 используется сервис `firewalld`

![](images/image69.png)

Зоны используются для создания разных правил в зависимости от типа трафика. Например можно создавать для пакетов приходящих из локальной сети отдельные правила нежели для пакетов приходящих из интернета

`firewall-cmd` утилита для настройки фаервола. Если используем ключ `--permanent` настройка сохранится постоянно, НО не примениться сию же секунду для runtime. Если не указываем `--permanent` применяем настройку в runtime, но не фиксируем навсегда

для отображения текущих настроек
```
firewall-cmd --list-all 
```

![](images/image64.png)

Начинается с зоны. По-умолчанию зона `public` , также зона имеет статус active. Также видим в interface одна сетевая карта на машине. Также видим сервисы. которым разрешено работать в данной зоне. Видим, что нет специализированных правил для ports

Список доступных сервисов
```
firewall-cmd --get-services 
```
![](images/image267.png)

Добавить сервис в фаервол
```
firewall-cmd --add-service name 
```
![](images/image406.png)

![](images/image381.png)

Обновить правила фаервола
```
firewall-cmd --reload 
```

![](images/image302.png)

Видим что после обновления правил, сервис `ftp` пропал. А все потому, что не применили опцию `--permanent`

![](images/image292.png)

Существует GUI утилита `firewall-config`, которую необходимо устанавливать.

![](images/image43.png)

# Linux time

![](images/image123.png)

Все начинается с аппаратных часов внутри оборудования. При загрузке система обращается к оборудованию и устанавливает время на уровне операционной системы. Если аппаратные часы в оборудовании не работают у системы будет неверное время. Есть команда `hwclock` которая позволяет узнавать время аппаратных часов, так и устанавливать их, синхронизировать системные и аппаратные часы.

Также существуют старая команда `date` для установки системного времени и получения системного времени.

Наиболее современная команда это `timedatectl`.

![](images/image222.png)

Нередки случаи когда сервера получают время от централизованного NTP сервера.

Через утилиту можно делать многие команды со временем.
```
timedatectl --help
```
![](images/image296.png)

Поменяем временную зону.

Сначала выведем список доступных временных зон.
```
timedatectl list-timezones
```
![](images/image10.png)

Затем установим зону.
```
timedatectl set-timezone Europe/Berlin
```

![](images/image439.png)

# Kickstart

Тулза для автоматической установки RHEL из файла конфигурации. Файл находится в home директории root и называется `anaconda-ks.cfg`

![](images/image356.png)

Обычно этот файл шарится через http и при установке новой машины, на него указывается ссылка

![](images/image331.png)

![](images/image217.png)

# Vagrant

Тулза для развертывания виртуальных машин

![](images/image93.png)

# Подключение сетевых дисков

## NFS
Используется для предоставления доступа к ресурсам по сети - создание сетевого диска.

Необходимо для установки:

1.  Запустить сервис nfs-service
```
systemctl status nfs-server.service
```

![](images/image16.png)

2.  Создать директорию, которую хотим шарить. Например /data
3.  Сконфигурировать файл `/etc/exports`
    ```
    /data * (rw,no_root_squash)
    ```

    ![](images/image339.png)
    `*` тут означает, что шарим любым ip адресами и dns именам (world wide welcome)

    `rw` значит все будут иметь права на запись. no_root_squash, если подключаемся с правами root, то будем иметь права в папке
4. Прописать 3 сервиса в фаерволе.
```
firewall-cmd --add-service nfs
firewall-cmd --add-service mountd
firewall-cmd --add-service rpc-bind
firewall-cmd --add-service rpc-bind --permanent
firewall-cmd --add-service mountd --permanent
firewall-cmd --add-service nfs --permanent
```

![](images/image47.png)

C клиентского сервера проверить доступен ли mount
```
showmount -e 192.168.4.210
```
![](images/image147.png)

Сделаем временный mount на клиенте
```
mount 192.168.4.210:/datda /mnt
```
![](images/image265.png)

Для постоянного монтирования внесем изменения в `/etc/fstab`

![](images/image186.png)

## Samba

Используется для предоставление доступа к ресурсам, которые поддерживают и Windows файлы

1.  Установим пакет для samba
```
yum install samba
```
![](images/image317.png)

2.  Создадим каталог для файлов, которые хотим шарить
```
mkdir /samba
```
![](images/image258.png)

3.  Создадим пользователя для samba
```
useradd samba
```
![](images/image23.png)

4.  Установим владельцем созданной папки созданного пользователя
```
chown samba /samba
chmod 770 /samba
```
![](images/image415.png)

![](images/image212.png)

5.  Установим пароль для пользователя samba для подключения
```
smbpassed -a samba
```
![](images/image433.png)

6.  Настроим файл конфигурации `/etc/samba/smb.conf`
```bash
[samba]
  comment = samba share
  path = /samba
  write list = samba
```   

![](images/image51.png)

![](images/image435.png)

7.  Стартуем сервис smb
```
systemctl enable --now smb
```
![](images/image166.png)

8.  Добавить сервис samba в файрвол
```
firewall-cmd --add-service samba --permanent
firewall-cmd --reload
firewall-cmd --list-all
```
![](images/image183.png)

9.  Поставить на папку и файлы в каталоге для расшариривания тип, который будет разрешать SELinux для сервиса samba

![](images/image456.png)


Подключаемся как клиент:

1.  Установить пакеты `cifs-utils` и `samba-client`

можно поставить группу пакетов `Network File System Client`
```
yum group install “Network File System Client”
```
2.  Проверить какие ресурсы доступны на сервере с самбой
```
smbclient -L //192.168.100.11
```
![](images/image216.png)

3.  Проверить монтирование в mnt
```
mount -o username=samba //192.168.100.11/samba /mnt
```
ввести пароль от пользователя samba

4.  Для постоянного монтирование укажем в fstab

![](images/image25.png)


# Проброс X11

Для того. чтобы сервер рисовал на экране клиента. Нужно сделать следующее.

### на сервере:

Для CentOS/RHEL 8

1.  поставить пакеты:  
```
sudo yum install xorg-x11-server-Xorg xorg-x11-xauth
```
![](images/image132.png)

для проверки можно поставить и пакет `xorg-x11-apps`, но в репозитории RHEL его нет. приходится делать так:

![](images/image274.png)

2.  в файле `/etc/ssh/sshd_config` поставить две строки:

![](images/image159.png)

3.  перезапустить сервис `sshd`.
```
systemctl restart sshd
```

### На клиенте:

1. установить X сервер. Например XMing. Также есть встроенный x сервер в Mobaxterm.

2. Далее при заходе через ssh указать опцию -Y.
```
например ssh -Y dima@192.168.0.32
```
Могут быть трудности. Из Putty при установке в меню опции 

![](images/image133.png)

и поднятом x сервере все работает ок.

Из gitbash и из powershell не заводится.

Лечится это установкой переменной окружения `DISPLAY=127.0.0.1:0`

![](images/image281.png)

![](images/image333.png)

![](images/image288.png)