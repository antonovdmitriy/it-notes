Содержание
==========
- [Содержание](#содержание)
- [Полезности bash](#полезности-bash)
  - [TAB - заполнение](#tab---заполнение)
  - [История](#история)
  - [Режим поиск Ctrl + R (удобная штука)](#режим-поиск-ctrl--r-удобная-штука)
  - [SSH (Secure Shell)](#ssh-secure-shell)
  - [Virtual terminals](#virtual-terminals)
  - [Нагрузка системы](#нагрузка-системы)
- [Операции с файлами и каталогами](#операции-с-файлами-и-каталогами)
- [Относительный путь и ссылки на директории](#относительный-путь-и-ссылки-на-директории)
- [Основные команды](#основные-команды)
  - [Команды помощи](#команды-помощи)
  - [ls](#ls)
  - [cat](#cat)
- [Фильтры](#фильтры)
  - [tr(translate)](#trtranslate)
  - [cut](#cut)
  - [sort](#sort)
  - [grep](#grep)
  - [sed (stream editor)](#sed-stream-editor)
  - [awk](#awk)
- [less](#less)
  - [Поиск](#поиск)
  - [Навигация](#навигация)
- [Мониторинг системы](#мониторинг-системы)
- [Монтирование дисков и файловые системы](#монтирование-дисков-и-файловые-системы)
  - [Файловые системы](#файловые-системы)
    - [XFS.](#xfs)
    - [Ex4.](#ex4)
  - [Партиции](#партиции)
    - [Отличия MBR и GPT](#отличия-mbr-и-gpt)
      - [MBR](#mbr)
      - [GPT](#gpt)
  - [Parted (утилита для работы с партициями)](#parted-утилита-для-работы-с-партициями)
  - [fdisk (утилита для MBR партиций)](#fdisk-утилита-для-mbr-партиций)
  - [Утилиты для создания файловых систем (форматирования)](#утилиты-для-создания-файловых-систем-форматирования)
  - [Mount партиций](#mount-партиций)
      - [Временный mount](#временный-mount)
      - [Постоянный mount через fstab](#постоянный-mount-через-fstab)
      - [mount через systemd mount](#mount-через-systemd-mount)
  - [Именование устройств (UUID, Label)](#именование-устройств-uuid-label)
  - [XFS бекапы](#xfs-бекапы)
  - [SWAP](#swap)
  - [LVM Logical volumes](#lvm-logical-volumes)
      - [Изменение размера logical volume](#изменение-размера-logical-volume)
  - [Stratis](#stratis)
      - [Изменение размера stratis volume](#изменение-размера-stratis-volume)
      - [Снепшоты](#снепшоты)
  - [VDO-виртуальный оптимизатор данных.](#vdo-виртуальный-оптимизатор-данных)
  - [LUKS encrypted volume](#luks-encrypted-volume)
- [Piping](#piping)
- [I/O Redirection](#io-redirection)
- [Использование regexp (globing)](#использование-regexp-globing)
- [Переменные окружения](#переменные-окружения)
  - [Область видимости переменных](#область-видимости-переменных)
- [Alias](#alias)
- [Vim](#vim)
  - [Команды выхода](#команды-выхода)
  - [Исправления действий](#исправления-действий)
  - [Навигация (иногда могут не работать стрелки)](#навигация-иногда-могут-не-работать-стрелки)
  - [Команды редактирования](#команды-редактирования)
  - [Режим выделения](#режим-выделения)
  - [Разное](#разное)
  - [Поиск](#поиск-1)
  - [Замена](#замена)
- [Links](#links)
- [Операции с архивами](#операции-с-архивами)
  - [tar \[OPTIONS\] &lt;name\_of\_archive&gt; &lt;directory_names&gt;...](#tar-options-name_of_archive-directory_names)
          - [tar cf - &lt;directory&gt; | gzip > &lt;directoryName&gt;](#tar-cf---directory--gzip--directoryname)
  - [gzip](#gzip)
- [Структура каталогов FHS](#структура-каталогов-fhs)
- [Поиск](#поиск-2)
          - [find /etc -size -1000с -exec cp {} /tmp/files/ \\;](#find-etc--size--1000с--exec-cp--tmpfiles-)
- [Cockpit](#cockpit)
          - [sudo systemctl enable --now cockpit.socket](#sudo-systemctl-enable---now-cockpitsocket)
- [Midnight Comander](#midnight-comander)
- [Linux comm](#linux-comm)
  - [To Display Single Column](#to-display-single-column)
- [Linux tee](#linux-tee)
- [Linux uniq](#linux-uniq)
  - [uniq -c](#uniq--c)
- [Запуск процессов по расписанию](#запуск-процессов-по-расписанию)
  - [Cron](#cron)
  - [at](#at)
  - [systemd-tmpfiles](#systemd-tmpfiles)
- [Команды времени](#команды-времени)
- [Virtual Box](#virtual-box)
  - [mnt дисков](#mnt-дисков)
- [Операции с правами](#операции-с-правами)
  - [File Permission](#file-permission)
  - [umask](#umask)
  - [Специальные права доступа](#специальные-права-доступа)
    - [GIUD](#giud)
    - [Sticky bit](#sticky-bit)
  - [ACL (Access Control List)](#acl-access-control-list)
  - [Примеры сложностей понимания прав доступа](#примеры-сложностей-понимания-прав-доступа)
    - [Удаление файла](#удаление-файла)
    - [Запись в файл](#запись-в-файл)
    - [Смена прав доступа](#смена-прав-доступа)
- [Операции с пользователями](#операции-с-пользователями)
  - [Свойства пользователя](#свойства-пользователя)
- [Операции с группами](#операции-с-группами)
- [Сеть](#сеть)
  - [NMCLI (Network Manager command line interface)](#nmcli-network-manager-command-line-interface)
    - [Создание новой конфигурации подключения](#создание-новой-конфигурации-подключения)
  - [nmtui (Network Manager text user interface)](#nmtui-network-manager-text-user-interface)
  - [Расположение файлов конфигураций сетевых интфейсов](#расположение-файлов-конфигураций-сетевых-интфейсов)
  - [Проверка сетевого соединения](#проверка-сетевого-соединения)
- [!Управление процессами](#управление-процессами)
  - [Сигналы](#сигналы)
  - [Профилирование системы](#профилирование-системы)
- [RPM(Red Hat Package Manager)](#rpmred-hat-package-manager)
  - [Пакеты](#пакеты)
  - [Модули](#модули)
  - [Группы](#группы)
  - [История изменений](#история-изменений)
- [Systemd](#systemd)
  - [Конфигурация юнитов](#конфигурация-юнитов)
    - [пример модификации конфигурации](#пример-модификации-конфигурации)
- [Логирование](#логирование)
  - [Rsyslogd](#rsyslogd)
  - [systemd-journald](#systemd-journald)
  - [logrotate](#logrotate)
- [/proc и ядро](#proc-и-ядро)
- [Загрузка (boot)](#загрузка-boot)
  - [systemd target](#systemd-target)
  - [Проблемы при загрузке](#проблемы-при-загрузке)
    - [Восстановление пароля root.](#восстановление-пароля-root)
    - [Проблемы при mount во время старта](#проблемы-при-mount-во-время-старта)
- [Bash Shell scripts](#bash-shell-scripts)
- [SSH](#ssh)
- [Копирование файлов по сети](#копирование-файлов-по-сети)
- [Rsync Синхронизация директорий по сети](#rsync-синхронизация-директорий-по-сети)
    - [опции:](#опции)
- [HTTP Server](#http-server)
- [SELinux](#selinux)
  - [Context label](#context-label)
  - [Изменение context label](#изменение-context-label)
  - [Чтение лога SELinux](#чтение-лога-selinux)
- [Firewalling](#firewalling)
- [Linux time](#linux-time)
- [Kickstart](#kickstart)
- [Vagrant](#vagrant)
- [NFS](#nfs)
- [Samba](#samba)
- [Automount](#automount)
    - [Проброс X11](#проброс-x11)

Полезности bash
===============

TAB - заполнение
----------------

При вводе команды, если нажать на двойной TAB выведется все команды начинающиеся на уже введенные символы.

![](images/image154.png)

История
-------

history отображение ранее выполненных команд

![](images/image417.png)

Повторить команду из истории !номер_команды, например !25

Также еще опасный способ повторить из истории !f команду начинающуюся на f

Режим поиск Ctrl + R (удобная штука)
------------------------------------

При входе в этот режим, подходящие команды найдутся в истории по нескольким символам

![](images/image430.png)

SSH (Secure Shell)
------------------

Подключиться на удаленный сервер под пользователем

ssh user_name@host

ssh dima@192.168.100.9

Можно подключиться даже из Git Bash и из CMD и из PowerShell, если ssh доступен в windows

Virtual terminals
-----------------

Если напрямую находимся в графическом интерфейсе, можно переключить виртуальные терминалы. Обычно 1 и 2 это графические терминалы, остальные консольные. Переключаться можно через Ctrl + Alt + номер_терминала. Либо через команду из под root сhvt номер_терминала.

Нагрузка системы
----------------

нагрузить процессор

dd if=/dev/zero of=/dev/null Копировать ничто в никуда

Операции с файлами и каталогами
===============================

cd \[path\]     изменить текущий каталог

mv filename1 filename2Переместить файл. Удобно использовать паттерны, например mv script* new_directory/

touch \[path\]    Создать пустой файл

можно создать много пустых файлов. touch myfile{0..10}

pwd  текущая директория

mkdir &lt;dirname&gt; ...Создать директории или несколько директорий

![Linux mkdir command 2](images/image386.png)

можно также создавать и подкаталоги сразу жеmkdir -p new/new/new

-v печатать то, что делается.

Если директория уже создана, то будет показываться ошибка. За исключением случаев, когда создаем my/my1/../myn  Ошибки не будет, если часть дерева уже есть.

rmdir \[path\] Удаляет ТОЛЬКО ПУСТЫЕ директории.

-p удалять родительские директории, если это необходимо

-v печатать то, что делается

cp &lt;source&gt; &lt;destination&gt; копировать файл

можно использовать паттерны. Например cp /etc/h* .(скопировать все файлы из директории в текущую). Если необходимо скопировать файлы в том числе из вложенных директорий тогда так cp -r /etc/h* .

rmКоманда удаления. Может удалять все. Поддерживает паттерны rm *extenstion

rm -rf ./scriptsУдаляет директорию scripts и все файлы в ней. -f опция для отключения предупреждений. Также есть опция -v, для отображения что удаляем-i для подтверждения удаления

Относительный путь и ссылки на директории
=========================================

. текущая директория

.. директория выше на уровень

 ../../директория выше на два уровня  

~ директория пользователя  

/ корень файловой системы

Linux допускает пробелы в названиях файлов. Но передачи пути необходимо в этом случае заключать это имя в кавычки ‘’, Или писать \ после первого слова

Скрытые файла начинаются с .  Если убрать точку, файл перестает быть скрытым

Основные команды
================

Команды помощи
--------------

man  \[command\]  Помощь по команде.

q выход

/ слово.  Поиск. Если найдено несколько n переходит к следующему слову.

Существует man man.

В нем написано, что существует несколько групп команд. В самом начале указан номер \- это группа команды. Детальнее см. man man

Можно искать по общей базе man через man -k \[regexp\].

Но может случиться так, что в системе еще не были проиндексированы страницы man. Тогда поможет команда mandb

help -m command У многих программ есть help  Короче чем man

file  \[location\] посмотреть тип файла. Поддерживает паттерны. file *

which Показывает расположение команды. Работает только с запускаемыми программами, находящимися в $PATH

ls
--

lscписок файлов в директории

ls -l посмотреть расширенные свойства файлов

-a     включая скрытые файлы

-h     чтобы размер файла представлялся не в байтах, а в единицах измерения (килобайтах, мегобайтах и тд.)

ls -lhS  отсортировать в порядке уменьшения размера

ls -lht  в порядке времени изменения

-rотобразить список в обратном порядке. например ls -lhSr

-R  отобразить содержимое вложенных папок

cat
---

catВывести в stdout текстовый файл. Вывести с конца tac

-A показать скрытые символы

-n вывести номера строк

Если не указать аргумент, то cat ждет данных от stdin потока, который по-умолчанию слушает консоль. Можно ввести строчку и нажать Ctrl+D , что значит EOF (end of file).

Также cat может принимать несколько аргументов и wildcard, например.

cat movie.mpeg.0* > movie.mpeg

Фильтры
=======

wc Количество строк, слов и байт текстового файла

Опции --bytes   ( c  )   --lines   (l)  -- words (w) - chars (m)

head         Показать первые n строк. Опция -n кол-во строк.

tail Показать последние n строк. Опция -n кол-во строк.

taif -f ./qshin.log  Отображать файл с конца \+ при добавлении в конец

Для расширенных регулярок нужно использовать не grep, а egrep. Например в grep не входит символ ?

tr(translate)
-------------

Используется для замены или конвертации. Перевод регистра, замена символов

command | tr &lt;'old'&gt; &lt;'new'&gt; Пример tr \[:lower:\] \[:upper:\] или tr \[a-z\] \[A-Z\]

![Linux tr Filters1](images/image444.png)

command | tr &lt;'\\n'&gt; &lt;' '&gt;   Замена перевода строки на пробел.

![Linux tr Filters3](images/image199.png)

command | tr -s &lt;'letter'&gt;   Устраняет множественный символ до одного

![Linux tr Filters2](images/image273.png)

command | tr -d &lt;letter&gt;   Удаляет символ

![Linux tr Filters5](images/image431.png)

cut  
-----

Команда удобна для выбора колонки из файла.

cut -d(delimiter) -f(columnNumber) &lt;fileName&gt; 

![Linux Cut Filter1](images/image345.png)

![Linux Cut Filter2](images/image277.png)

sort
----

sort &lt;fileName&gt; Сортирует строки в алфавитном порядке

sort -k&lt;columnNumber&gt; &lt;fileName&gt;  Выбор по какой колонке сортировать

![Linux Sort Filters2](images/image202.png)

Опция -n сортирует не по алфавиту, а по числовому признаку

sort -n -k&lt;columnNumber&gt; &lt;fileName&gt;  

![Linux Sort Filters3](images/image377.png)

grep
----

command | grep &lt;searchWord&gt;   Обычно используется в пайпах

cat marks.txt | grep 9 

А можно и без пайпа , например искать в файлах

grep &lt;searchWord&gt; &lt;file name&gt; -l отображает не содержимое, а имя файла

![Linux Grep Filters2](images/image260.png)

grep -i &lt;searchWord&gt; &lt;fileName&gt;  Регистронезависимый поиск

![Linux Grep Filters4](images/image413.png)

grep -A&lt;lineNumber&gt; &lt;searchWord&gt; &lt;fileName&gt;  Отобразить n строк после найденного

grep -B&lt;lineNumber&gt; &lt;searchWord&gt; &lt;fileName&gt;  Отобразить n строк перед найденным

grep -C&lt;lineNumber&gt; &lt;searchWord&gt; &lt;fileName&gt;  Отобразить n строк перед и после

![Linux Grep Filters5](images/image215.png)

grep -Rl root /etc Рекурсивный поиск фрагмента по директориям. Удобно с -l

sed (stream editor)
-------------------

Используется для применения регулярных выражений.

command | sed 's/&lt;oldWord&gt;/&lt;newWord&gt;/'  

![Linux Sed Filter1](images/image122.png)

command | sed 's/&lt;oldWord&gt;/&lt;newWord&gt;/g'  Для применения ко всем найденным

![Linux Sed Filter2](images/image221.png)

cat &lt;fileName&gt; | sed '/&lt;Word&gt;/d'  Удалить строку с фразой

![Linux Sed Filter3](images/image252.png)

Для работы с файлами : sed -i ‘s/four/FOUR/g’ &lt;file_name&gt;

Помимо замены sed используется и для редактирования файлов и потоков.

sed -n 4p &lt;file&gt; отобразить 4 строку в файле

awk
---

Одна из самых мощных и старых утилит. Целый язык в себе

awk ' /'pattern'/ {print $2} ' Печатает только элементы второго столбца, соответствующие шаблону "pattern", используя stdin

опция -F указывает разделитель

 echo 'one two three four' | awk '{print $NF}'

вывести последнее поле four

less
====

простой просмотрщик файла. Именно он на самом деле показывает man странички

Поиск
-----

/ поиск с подсветкой.  nперейти к следующему найденному фрагменту Nк предыдущему ? Поиск с конца файла

Навигация
---------

jПеремещение вниз, kперемещение вверх

gк началу файла Gк концу файла

qили ZZ выход

Мониторинг системы
==================

free Просмотр использования оперативной памяти.  -h вывести в GB -m вывести в Mb

![](images/image194.png)

Общий обьем память. Используемая память в данный момент. Дальше важно понимать, что линукс неиспользуемую память использует для своих нужд, доступ к файлам происходит намного быстрее, если они имеются в RAM. Часто выглядит будто серверу недостаточно памяти, но это не так. Кеш освобождается тогда, когда память реально потребуется. Avaliable-кол-во памяти доступное прямо сейчас.

df  свободное пространство на диске (disk free). Удобнее выводить с -h опцией

![](images/image150.png)

uptimeПоказывает время работы системы с последного перезапуска и также среднюю нагрузку процессора за минуту, за пять минут, и за 15 минут

![](images/image32.png)

чтобы увидеть изменения в динамике полезна команда watch uptime.

Каждые 2 секунды выполняется команда.

![](images/image452.png)

Важно понимать, что даже если 1 ядро, нагрузка процессора может быть больше чем единица. Например 2.5. Это значит, что процессор крайне перегружен. В то же время, если бы ядер было 4, нагрузка 2.5 допустима для такой системы.

lscpu Показывает информацию о процессоре (кол-во ядер, кол-во потоков)

![](images/image134.png)

top Отображат дашборд состояния системы

Полезные клавиши:

* f Переходим в режим управления отображением. Тут можно выбрать какие поля отображать (d или Пробел) и по каким сортировка (s)
* M отсортировать по памяти P по процессору
* W сохранить настройки топ в настройки пользователя
* s установить время обновления
* c показать полную команду
* e изменить единицы измерени памяти в основной таблице E - в шапке
* m. Менять отображение памяти, с таблицы на bar. t - менять отображение процессора
* z включить цветной режим
* o наложить фильтр Например command=gnome %cpu>3.0 Сбросить фильтр =
* u выбрать процессы пользователя
* k послать kill процессуc
* С скролинг
* Y перейти в режим просмотра output процесса
* x показать колонку сортировки b - bold режим
* V дерево процессов
* \+ обьяснение написать различных типов нагрузки процессора

Монтирование дисков и файловые системы
======================================

findmnt Посмотреть структуру смонтированных разделов

![](images/image5.png)

Файловые системы
----------------

### XFS.

По-умолчанию в RHEL 8 файловая система XFS.

Особенности: быстрая и маштабируемая, использует парадигму CoW(copy on write) - это позволяет отменять возвращать состояние файла к преждему состоянию, размер может быть увеличен, но не уменьшен, что является по мнению некоторых минусом

### Ex4.

Была по-умолчанию в RHEL 6. Все еще используется. Имеет обратную совместимость с ex2. Использует парадигму журналов, которая позволяет отслеживать момент изменения файла и в случае ошибок, возвращать состояние к предыдущему. Размер может быть и увеличен и уменьшен.

Партиции
--------

Партиции это области диска, которые позволяют изолировать данные. Используются для выделения памяти для определенного типа данных. Например под /home обычно выделяют отдельную партицию для изолирования доступа. У партиции есть имя. Пример /dev/nvme0m для ssd  sda для HDD дисков, /dev/vda для дисков KVM систем. Если диск HDD парциции будет с похожими названиями /dev/sda1, /dev/sda2, /dev/sda3, /dev/sda4,

Системы различаются по типу загрузчика:

BIOS: ограничены только 4-мя партициями В этой системе есть MBR (master boot record). Для преодоления ограничения на кол-во партиций используется Logical partition (партиция создаваемая внутри extended partition). Обычно extended партиция это sda4. Она обычно представляет собой все оставшееся место на диске, которое не занимают sda1-3. Нумерация logical partition начинается с 5, т.е sda5.

UEFI (Universal Extended firmware interface), ограничения в 128 партиций. В ней используются GPT ([GUID](https://www.google.com/url?q=https://ru.wikipedia.org/wiki/GUID&sa=D&source=editors&ust=1662229049481587&usg=AOvVaw22z4U0z8_fyiMo9l9PSUxy) Partition Table)

### Отличия MBR и GPT

#### MBR

Часть спецификации 1981 PC

512 байт для хранения информации о загрузке

64 байта для хранения информации о патициях

Максимальное кол-во партиций 4, с максимальным обьемом 2TБ

Для использования большего числа партиций используются extended и logical партиции

#### GPT

2010 год изобретения

Изобретено для преодоления ограничения MBR

128 партиций максимально

В настоящее время используются оба типа загрузки. Если это большой сервер, скорее всего там UEFI и GPT, если это виртуальная среда, вполне возможно, что там MBR.

![](images/image310.png)

lsblk Посмотреть block устройства

![](images/image284.png)

loop0- примонтированный iso файл для репозитория

sr0   - CD-ROM

sda - партиции

parted &lt;путь_до_партиции_обычно/dev/name&gt; Утилита для работы с партициями

![](images/image297.png)

Также список партиций можно найти в /dev директории

![](images/image351.png)

А также cat /proc/partitions

![](images/image41.png)

Parted (утилита для работы с партициями)
----------------------------------------

По-умолчанию в RHEL 8. Более ранние утилиты fdisk для работы с MBR и gdisk для работы c GPT.

Команды:

print распечать информацию об устройстве, в том числе и список партиций

mklabel gpt для GPT или msdos для MBRСоздать запись о типе партиций

mkpart &lt;part-type&gt; &lt;name&gt; &lt;fs-type&gt; &lt;start&gt; &lt;end&gt;

&lt;part-type&gt; Только для MBR. Значения primary, logical, extended

&lt;name&gt; Имя партиции. Обязательно для GPT

&lt;fs-type&gt; Тип файловой системы. Добавляет метаданные о типе системы, причем сама файловая система не меняется.

&lt;start&gt; &lt;end&gt; начало и конец партиции на диске. Обычно в MiB

Можно использовать mkpart без аргументов, тогда утилита будет спрашивать опции необходимые для создания партиции последовательно

quit выйти из утилиты parted

После добавление партиции необходимо выполнить

udevadm settle

cat /proc/partitions

lsblk Увидим подключенные устройства

![](images/image12.png)

Видим, что подключен HDD диск, у которого размечены две партиции. Создадим еще одну партицию, т.к видно, что размер диска 40 G, а партиции занимают только 20G.

Войдем в parted с именем устройства, выведем через print текущие партиции

![](images/image418.png)

Видим, что у нас диск содержит MBR записи, т.к Partition Table: msdos

![](images/image256.png)

Выходим из parted и получаем оповещение, что необходимо обновить fstab

![](images/image451.png)

Возможна и другая ситуация. Предположим у нас подключился новый SSD диск.

![](images/image363.png)

Войдем в parted

![](images/image416.png)

Видим, что диск еще не содержит никаких записей и даже не имеет типа. Укажем тип GPT для создания GPT партиций. mklabel gpt для GPT или msdos для MBR

![](images/image156.png)

Теперь можно размечать партиции mkpart  &lt;type\_or\_name&gt; &lt;start&gt; &lt;finish&gt;

![](images/image26.png)

fdisk (утилита для MBR партиций)
--------------------------------

![](images/image174.png)

Все изменения будут в памяти, для их применения нужно нажать w.

Полезно нажать m и увидеть справку по командам

![](images/image291.png)

Список партиций

![](images/image48.png)

Создадим партицию

![](images/image83.png)

Т.к MBR допускает только 4 партицию, 4-ую партицию сделаем extended для возможности разделения на подпартиции

![](images/image372.png)

Команда понимает, что осталась свободной только одна партиция и предлагает выбрать тип e (extended)

![](images/image231.png)

Для сохранения результатов наберем w

![](images/image88.png)

Если теперь создадим новую партицию, она будет создаваться внутри адресов 4-ой партиции.

![](images/image65.png)

Иногда при операциях с партициями могут возникнуть ошибки занятости партиции. Для их идентификации можно выполнить команду partprobe

Утилиты для создания файловых систем (форматирования)
-----------------------------------------------------

После создания партиции необходимо создать файловую систему в ней. В RHEL есть несколько утилит, начинающихся с mkfs. Введем команду и нажмем два раза TAB, чтобы увидеть все варианты

![](images/image289.png)

Создадим xfs систему в созданной ранее партици

![](images/image241.png)

Mount партиций
--------------

#### Временный mount

После того как партиции созданы и в ней создана файловая система, можно сделать mount партиции, т.е присоединить к дереву каталогов FHS.

Для временного mount используется команда mount &lt;/dev/partition\_name&gt; &lt;to\_dir&gt;

![](images/image6.png)

Команда lsblk показывает не только список устройств и партиций, но и точки монтирования партиций

![](images/image170.png)

для того чтобы отсоединить партицию от каталога используется

umount &lt;/dev/partition\_name&gt; или &lt;partition\_mount_directory&gt;

![](images/image62.png)

Если вызвать команду mount без аргументов, отобразится список всех mount точек системы. Довольно большой

![](images/image364.png)

полезно отобразить mount реальных устройств

mount | grep ‘^/’

![](images/image312.png)

При операции umount могут возникнуть ошибки в случае, если файлы заняты чем-то. Например, если примонтируем партицию, далее зайдем в каталог и попытаемся сделать umount

![](images/image31.png)

Чтобы понять кто заблокировал каталог, используется команда lsof &lt;path&gt;

![](images/image97.png)

Также стоит помнить, что после перезагрузки системы, точки монтирования слетят.

#### Постоянный mount через fstab

/etc/fstab    Файл конфигурации постоянного монтирования партиций

Точки монтирования из этого файла загружает systemd-fstab-generator и создает systemd mount. Также systemd mount можно создавать и самостоятельно, без fstab.

После редактирования файла для применения изменений необходимо выполнить systemctl daemon-reload

Отредакируем файл /etc/fstab

![](images/image107.png)

![](images/image92.png)

Выполним команду systemctl daemon-reload, далее создадим директорию для точки монтирования, которую указали в fstab. Потом применим mount -a для того, чтобы применить точки монтирования из fstab. Далее убедимся, что точка монтирования создана

![](images/image71.png)

#### mount через systemd mount

Точки монтирования описываются в .mount файлах. В файлах можно более детально описать зависимости точек монтирования, например последовательность монтирования. Монтиование можно включать и выключать по требованию. В fstab прописываются постоянно активные точки монтирования. Рассмотрим на примере файл tmp.mount

![](images/image161.png)

Тут важная часть Mount. Описывается что монтируем и куда, также тип файловой системы.

Поменяем точку монтирования, которую создали ранее в fstab на systemd mount.

Откроем fstab и уберем строчку монтирования.

/etc/systemd/system каталог для пользовательских файлов .mount

Проще всего создавать mount копируя уже созданный mount в директорию и подправляя как необходимо.

cp /usr/lib/systemd/system/tmp.mount /etc/systemd/system/movies.mount

Название не призвольное, оно отражает куда будет осуществляться монтирование. Т.е movies.mount будет монтироваться в /movies. Для указания вложенности используется дефис. Например data-movies.mount указывает на /data/movies

![](images/image4.png)

Для того, чтобы systemd забрал изменения из файлов конфигураций выполним.

systemctl daemon-reload

Выведем статус movies.mount

![](images/image27.png)

Обратим внимание на путь. Он таков потому, что точка монтирования уже была и mount сгенерирован из fstab. Для того, чтобы путь изменился, необходимо перемонтировать точку.

![](images/image262.png)

![](images/image45.png)

![](images/image434.png)

Именование устройств (UUID, Label)
----------------------------------

В процессе работы с партициями могут возникнуть неприятная ситуация. Когда заполняем fstab точками монтирования указываем путь до партиции, точнее ее имя. Что произойдет, если мы удалим партицию 4, а у нас была партиция 5. Произойдет ошибка при запуске системы, т.к партиция с именем 5 станет партицией 4. Для того, чтобы этого не произошло у партиции есть уникальный UUID, который автоматически создается при создании файловой системы. А также можно создать собственный LABEL, для именования партиции.

Пример проблемы:

Создадим две логических партиции внутри extended партиции.

![](images/image108.png)

![](images/image163.png)

Создали две партиции. Через команду blkid можно увидеть информацию об Id партиции.

![](images/image380.png)

Видим, что у созданных партиций нет еще UUID. Т.к он создается при создании файловой системы. Создадим их. Для примера сделаем xfs и ext4

![](images/image304.png)

![](images/image450.png)

Далее выведем через blkid информацию и увидим, что UUID сгенерировался.

![](images/image187.png)

Добавим в fstab точку монтирования, в которой используются явный путь до устройства

![](images/image401.png)

![](images/image338.png)

![](images/image126.png)

А теперь удалим одну из партиций.

![](images/image395.png)

Система говорит, что сейчас удалить партицию нельзя, но после перезагрузки это будет сделано. Перезагрузим компьютер и...получим ошибку загрузки.

![](images/image29.png)

![](images/image191.png)

![](images/image178.png)

![](images/image328.png)

Возможно дело в том, что в fstab осталась запись о партиции которая была удалена?Попробуем исправить.

![](images/image337.png)

Теперь удаленную партицию закомментировали в fstab.

![](images/image233.png)

Проблема не ушла. Дело в том, что партиция 6 изменила свое имя на 5, т.к 5-ая была удалена. Видим, что только 5 партиций, а в fstab указан путь до /dev/sda6

![](images/image195.png)

Чтобы монтирование не слетало, придумано два способа UUID, который создается при формировании файловой системы. Его можно указать в fstab. А также label. Создадим метку для партиции 5 и примонтируем ее правильно. Для начала закоментируем монтирование в fstab чтобы система нормально загрузилась.

![](images/image342.png)

Создадим метку на партиции. Есть несколько утилит для этого tune2fs (для ext файловых систем) и xfs_admin (для xfs)

Создадим метку для партиции

tune2fs -L movies /dev/sda5

![](images/image111.png)

далее поменяем точку монтирования в /etc/fstab

![](images/image141.png)

![](images/image46.png)

Теперь будет не важно, если название партиции поменяется. Также можно написать UUID, но он не будет настолько читаемым. В картинке наверху видно, что /boot монтируется именно через UUID

Также есть каталог /dev/disk , где расположены ссылки на партиции и устройства по различным критериям

![](images/image357.png)

XFS бекапы
----------

xfsdump команда для работы с бекапами xfs файловых систем. Может создавать полные бекапы или бекапы с определенного уровня.

xfsdump -l 0 -f /backupfiles/data.xfsdump /data Создает полный бекап директории /data и записывает файл бекапа в /backupfiles/data.xfsdump

xfsrestore -f /backupfiles/data.xfsdump /data Восстанавлиет из файла бекапа и записывает в /data

xfsrepair команда для восстановления поломанных участков xfs

SWAP
----

Создадим swap-партицию.

![](images/image242.png)

![](images/image385.png)

После создании партиции необходимо создать файловую систему на ней командой

mkswap &lt;partition_path&gt;

![](images/image254.png)

Создали файловую систему на своп-партиции. Далее необходимо присоединить партицию к свопу командой swapon &lt;partition&gt;

![](images/image208.png)

Это не персистентное монтирование. Для постоянного монтирования необходимо либо отредактировать /etc/fstab , либо создать mount файл в /etc/systemd/system

![](images/image52.png)

Можно использовать команду swapon -a , которая применяет точки монтирования swap из fstab

LVM Logical volumes
-------------------

Использьуются по-умолчанию при установке RHEL. Можно изменять размер, делать снепшоты и пр.

![](images/image115.png)

Суть простая: группы дисков, партиций обьединяем в группу с определенным именем. Это Volume Group. Из volume Group создаются logical volume, которые никак не соотносятся с физическии устройствами. Т.е физические устройства обьединяются в большой пул памяти, который уже разделяется на произвольное кол-во logical volume. Группы можно монтировать в директории, создавать в них различные файловые системы. Находятся в /dev/vg/

В отличие от реальных дисков могут logical volume. могут содержать очень большие обьемы данных. Например имеем 2 по 1TB диска, обьединяем их в volume group и можем создать одну группу 2TB, будто бы на одном устройстве. Т.е деление logical volume может быть совсем другим нежели physycal volume

Для создания volume group

* создать партицию partedдалее s set &lt;number_partition&gt; lvm on

![](images/image344.png)

Тип файловой системы неважен, т.к все равно будет создавать новую файловую систему при создании logical volume

![](images/image68.png)

* pvcreate /dev/sda3 для создания physical volume

![](images/image446.png)

командой pvs просматриваем список physical volumes. Видим, что у sda Volume group еще не указана

* vgcreate vgdata /dev/sda3 для создания volume group

![](images/image151.png)

Видим, что volume group теперь указана. Также командой vgs просмотрим список volume groups

![](images/image306.png)

* lvcreate -n lvdata -L 1G vgdata для создания logical volume

![](images/image346.png)

Командой lvs увидим список logical volumes

* mkfs.&lt;file_system&gt; /dev/vgdata/lvdata  для создания файловой системы.

![](images/image347.png)

* создать точку монитирования в fstab

![](images/image119.png)

![](images/image1.png)

![](images/image30.png)

#### Изменение размера logical volume

![](images/image412.png)

При необходимости увеличения размера logical group нужно понимать, доступно ли свободное место в volume group. Для этого поможет команда vgs. Если доступно, тогда применяем команду lvextend -r.

lvextend -r -L +1GУвеличит volume на 1Гб, за счет volume group. Увеличение произойдет и в файловой системе

Если забыли фложок r, то существуют утилиты для увеличения непосредственно в файловой системе:

если

e2resize для Ext-файловых систем

xfs_grows для xfs. Уменьшение размера невозможно.

Если в volume group нет свободного места придется присоединять к volume group другие устройства командой vgextend.

Хотим увеличить размер logical volume

![](images/image300.png)

Видим, что volume group имеет 0 доступных мегабайт. Придется добавлять туда свободного диска.![](images/image399.png)

Stratis
-------

Новое поколение разделения разделов. Появилось в RHEL8.  Он реализован в пользовательском пространстве, что также делает возможным доступ к API, что означает, что к нему можно обращаться из разных приложений, что является полезным решением, где используются облака, виртуализация или контейнеры

Технология от RedHat. Конкурент ZFS и Btrfs. Поверх при необходимости XFS. Может строится на любом блочном устройстве, в том числе LVM, но не на партиции

Преимущества:

* thin provisitoning Может представить из себя 10 ТБ, хотя данных будет на 500 мегабайт.
* Снепшоты \- бекапы
* Слой кеша. Может быть доступен из программ.

Stratis Pool состоит из одного или нескольких устройств. Создается директория для каждого пула /dev/stratis/my-pool, в которой содержатся ссылки на устройства помещенные в пул. Поверх volume создается XFS.Но каждый пул может иметь и несколько файловых систем.

yum install stratis-cli stratisd Устанавливаем эти пакеты для работы со Stratis

![](images/image7.png)

systemctl enable --now stratisd Активиуем stratisd сервис

![](images/image58.png)

stratis pool create mypool /dev/sdb Cоздаем stratis pool на основе устройства. Партиции не поддерживаются. Минимальный объем 1 ГБ

![](images/image175.png)

![](images/image330.png)

stratis fs create mypool myfs1 Создаем файловую систему XFS

![](images/image77.png)

![](images/image375.png)

stratis fs list mypool Отображаем список файловых систем в пуле.

![](images/image423.png)

mkdir /myfs1 Создадим каталог для точки монтирования

mount /dev/stratis/mypool/myfs1 /myfs1 Смонтируем

![](images/image19.png)

stratis pool list Отобразим список пулов Stratis

![](images/image139.png)

stratis fs list Отобразим список файловых систем

![](images/image121.png)

Отобразим список устройств через lsblk

![](images/image109.png)

Увидим, что монтирование насоздавало кучу длинных названий в sdb. Именно поэтому рекомендуется монтировать через UUID.

![](images/image185.png)

Скопируем UUID и вставим в fstab

![](images/image280.png)

#### Изменение размера stratis volume

Stratis pool может быть увеличен добавлением еще одного устройства.

stratis pool add-data mypool /dev/sdc Cоздаем устройство в пул

#### Снепшоты

* Снепшоты это индивидуальная файловая система, которая может быть замонтирована
* После создания снепшот можно изменить
* Снепшот и оригинальный образ никак не связаны
* Каждый снепшот должен содержать минимум половину гигабайта на лог xfs

stratis fs snapshot mypool myfs1 myfs1-snapshot Cоздаем снепшот существующей файловой системы. Причем изменения в оригинальном обьекте никак не отразятся на снепшоте.

![](images/image87.png)

![](images/image75.png)

mount /stratis/mypool/myfs1-snapshot /mnt Монтируем снепшот

![](images/image232.png)

Заменить оригинальную файловую систему на снепшот

umount /myfs1

stratis fs destroy mypool myfs1

stratis fs snapshot mypool myfs1-snapshot myfs1

Снепшоты Stratis не работают с устройствами LVM

stratis fs destroy mypool myfs1-snapshot Удалить снепшот

stratis fs destroy mypool myfs1Удалить файловую систему

Когда в пуле нет файловых систем, можно удалить пул.

Особенность. Если посмотреть df -h , увидим довольно странные данные.

![](images/image384.png)

1 Терабайт для точки монтирования, хотя у нас гораздо меньше физические диски в stratis пуле.Не нужно смотреть использование через df в случае с Stratis пулом.

VDO-виртуальный оптимизатор данных.
-----------------------------------

Появился в RHEL 8. Фокусируется на наиболее эффективном хранении файлов, управляет дедуплицированными и сжатыми пулами хранения. А в остальном похоже на Stratis.

Минимум 4 GB должно свободны на устройстве.

yum install vdo kmod-kvdo Устанавливаем пакеты

![](images/image429.png)

vdo create --name=vdo1 --device=/dev/sdd --vdoLogicalSize=10T Создаем vdo

![](images/image152.png)

mkfs.xfs -K /dev/mapper/vdo1 Создаем файловую систему

![](images/image341.png)

udevadm settle Применяем изменения в наименованиях устройств

![](images/image211.png)

Монтируем ![](images/image419.png)

Обязательно указываем x-systemd.requires=vdo.service

vdostats --human-readable Мониторинг vdo

![](images/image189.png)

LUKS encrypted volume
---------------------

Используются партиции. Т.е нужно создать партицию , через parted, либо fdisk или gdisk

![](images/image95.png)

![](images/image124.png)

cryptsetup luksFormat  Создает заприптованный уровень над партицией

![](images/image422.png)

cryptsetup luksOpen &lt;name\_of\_device&gt;  “Открыть” устройство

После этого создается устройство /dev/mapper/&lt;name\_of\_device&gt;

![](images/image38.png)

Далее необходимо создать файловую систему на новом устройстве и замаунтить

![](images/image398.png)

Если кто-то сопрет диск, он не сможет открыть это устройство, т.к необходим пароль.

Для автоматизации “открытия” устройства при старте используется /etc/crypttab

а для монтирования устройства /etc/fstab

![](images/image89.png)

![](images/image454.png)

мануал man crypttab

При перезагрузке системы появляется окно

![](images/image157.png)

Если несколько раз ввести пароль неправильно или не вводить, система все равно загружается, но секретное устройство не монтируется.

Piping
======

Перенаправление результатов предыдущей команды в аргументы последующей. Точнее stdout поток первой в stdin поток второй команды.

ls -l | less

ps aux | less    Выводим список процессов и перенаправляем в редактор less для удобного скролинга

[du](https://www.google.com/url?q=http://linuxcommand.org/lc3_man_pages/du1.html&sa=D&source=editors&ust=1662229049510134&usg=AOvVaw3F2l2I0JxcEjSB0mTK_ctE) | sort -nr Список директорий и размер их. Далее сортируем по числам (n) и инвертируем список ( от большего к меньшему делаем)

I/O Redirection
===============

ls > file_list.txt Перенаправление stdout в новый файл

ls >> file_list.txt Не создаем новый файл, если уже  существует

sort < file_list.txt Берем аргументы из файлы

sort &lt; file\_list.txt &gt; sorted\_file_list.txt

Берем аргументы из файла и переводим вывод в другой файл

Можно перенаправлять поток ошибок (stderr) , иногда полезно чтобы ошибки не отображались вовсе, тогда перенаправляем в стандартное место для этого

ls . sdfsdfsdf 2> /dev/null

Чтобы и stdout и stderr направлялись в один файл

ls -l /bin/usr > ls-output.txt 2>&1

И ещ вариант того же  
ls -l /bin/usr &> ls-output.txt  
ls -l /bin/usr &>> ls-output.txt

Использование regexp (globing)
==============================

ls host*

ls ?ost*

ls \[mh\]ost

ls \[!mh\]ost

ls host\[0-9\]\[0-9\]

Переменные окружения
====================

 printenvили env Показать переменные      

printenv JAVA_HOME Показать опреденную переменную

Область видимости переменных
----------------------------

Если присваиваем переменную в терминале или скрипте LANG=he_IL.UTF-8

и она уже существует, то перезатирается в текущей сессии, но не глобально. Если не существует, то ее называют shell variable, которую можно экспортировать во временную переменную окружения export LANG, а можно и сразу с присваиванием export LANG=he_IL.UTF-8

В случае если необходимо установить глобальную постоянную переменную окружения для всех пользователей, то есть несколько способов.

1.  Файл /etc/environment.    В нем просто через равно перечисляем переменные, нельзя пользоваться ссылками через $
2.  Каталог /etc/profile.d  Там можно написать скриптик .sh в котором написать что-то вроде этого.

export JAVA_HOME=/usr/lib/jvm/jdk1.7.0  
        export PATH=$PATH:$JAVA_HOME/bin

для конкретного пользователя

$ echo 'export PATH=$PATH:/usr/local/go/bin' >> $HOME/.profile

$ source $HOME/.profile

Alias
=====

alias Показывает список команд ссылок на другие команды

![](images/image327.png)

создать новый  alias h=history

Vim
===

Все команды изполняем в командном режиме. Находимся в нем сразу при запуске. Вернуться в него из других режимов нажать Esc. Перейти в режим редактирования a или i или Ins

Команды выхода
--------------

:wсохранить :qвыйти. Сохранить и выйти :wq

:q! выйти и не сохранять

Исправления действий
--------------------

u Отменить действие

ctrl r   Вернуть действие

Навигация (иногда могут не работать стрелки)
--------------------------------------------

jвниз kвверх hлево l право

G перейти на последнюю строчку файла

2G перейти на вторую строчку файл и так далее

gg перейти в начало файла

0начало строки $$ конец строки

В коде, где встречаются ) } \]  перейти к соответствующей скобке %   т.е Ctrl + 6

Команды редактирования
----------------------

ddудалить строку d$ удалить с текущего места и до конца строки

yyкопировать строку yскопировать выделение pвставить

Режим выделения
---------------

v переход в визуальный режим. Текст при движении выделяется. С ним что-то можно сделать например x  или r или d

Разное
------

.Повторить предыдущую команду

Ввести много раз одно и тоже.  100 + i + Dima + Esc

Также можно вводить или стирать например 50 новых строче 50 + i + Enter + Esc

b начало слова    

e конец слова

w начало следующего слова

можно перемещаться   eeee    wwwww или назад bbbbb

можно много раз вперед 100 + e

Ctrl X + Ctrl Fавтодополнение файлов в процессе набора

x стереть символ под курсором

X стереть символ слева от курсора

Заменить символ под курсором не переходя в режим insert. r символ.

Удалить d совмещается с символами движения. Например удалить 2 слова d2w

Поиск
-----

Поиск c начала файла /введем слово потом Enter nперейти к следующему shift n к предыдущему . Можно вводить регулярки

Также можно искать с конца файла ?затем слово и Enter

Найти текущее слово вперед *\* т.е ctrl 8

Найти текущее слово назад  #   т.е ctrl 3

:nohсбросить выделение

Замена
------

:%s/old/new/g

Links
=====

В линуксе два типа ссылок : hard links и symbolic links.

У каждого файла в системе, есть так называемый inode (указатель на файл в памяти). Hard link указывает на inode. Может быть несколько имен у файла, каждое имя или hard link указывает на inode. Причем у inode есть числовое поле, в котором содержится число hard линков, которые указывают на него. Symbolic link указывает на hard link

Пример использования

Создадим hard link на файл etc/hosts

![](images/image78.png)

Выведем список файлов и увидим, что ссылка на inode у двух файлов одинаковая

![](images/image131.png)

Создадим symbolic link

![](images/image162.png)

Удалим файл /etc/hosts и увидим, что simbolic link сломался

![](images/image63.png)

Но ничего страшного, можем запросто восстановить прежний файл, т.к как таковой файл у нас есть, просто нужно создать hard link

![](images/image127.png)

ln -s /path/to/file /path/to/symlink Создать symbolic link

ln -sf /path/to/file /path/to/symlink Отредактировать symbolic link

ln -s /var .  Создать ссылку на var в текущей директории

Операции с архивами
===================

tar \[OPTIONS\] &lt;name\_of\_archive&gt; &lt;directory_names&gt;...
--------------------------------------------------------------------

Используется для архивации директории. Для опций \- необязателен.

Опции:

с создать v отображать процесс в stdout f для указания названия целевого файла

z использовать ли компрессию gzip

###### tar cf - &lt;directory&gt; | gzip > &lt;directoryName&gt;  

или

tar cvfz office.tar.gz office

![Linux gzip Filters4](images/image226.png)x Распаковать архив в текущую директорию tar -xvf имя_архива

Можно указать расположение целевой директории

tar -xvf articles.tar -C /tmp/my_article/

t Показать содержимое архива  tar -tvf имя_архива

gzip
----

команда архивации. По-умолчанию файл будет помещен в архив с расширением (.gz). Причем оригинальный файл пропадет. -k-сохранить оригинальные файлы.              Если файлов передано несколько, будет создано несколько архивов. Для обратной операции есть команда gunzip

gzip &lt;file1&gt; &lt;file2&gt; &lt;file3&gt;. . .  

gunzip &lt;file1&gt; &lt;file2&gt; &lt;file3&gt;. . .  

![Linux gzip Filters1](images/image182.png)

-lПоказывает после архивации как сильно был сжат архив

![Linux gzip Filters3](images/image428.png)

Структура каталогов FHS
=======================

для RetHat  man hier. Описывает структуру каталогов. Для debian не работает.

/boot/vmlinuz ядро линукса.Команда file дает детальную инфу о нем.

/devУстройства компьютера показанные в виде файлов

/etc/ Файлы конфигураций

/etc/fstabфайлик где примаплены физические устройства, когда система загружается.

/etc/hosts Файлик с мапингом ip адресов и имен

/etc/init.d Скрипты запускаемые при загрузке. Можно сюда всандаливать свои

Для RedHad /etc/redhat-release   Файл с именем версии

НО для всех систем  /etc/os-release

![](images/image414.png)

![](images/image203.png)

/bin, /usr/binПрограммы для системы и для пользователя

/sbin, /usr/sbinПрограммы для администрирования

/usr/local Программы и файлы для пользователя. Если хотим установить программу, которая не входит в дистрибутив, то ставим ее сюда, либо в /usr/local/bin

/var/logФайлы лога операционной системы

/lib Библиотеки операционной системы

/tmpВременные файлы программ

/procВиртуальная директория. Тут список процессов плюс инфо об устройствах. Например /proc/cpuinfo.

Поиск
=====

find Поиск файлов в директории

find . -name "*.txt"   Поиск по имени

![Linux Find1](images/image308.png)

find . -type d -name "*.bak"  поиск по типу

f:regular file d:directory l:symbolic links c:character devices b: block devices

![Linux Find2](images/image329.png)

find / -type f -size +100M

Поиск файлов по всей системе больше превышающих размер 100 Мб

![](images/image334.png)

Можно задавать последующие команды через опцию -exec

###### find /etc -size -1000с -exec cp {} /tmp/files/ \\;

locate &lt;fileName&gt; Команда позволяет искать файлы. Но в отличие от find она ищет в базе данных файлов. Поэтому поиск значительно быстрее. Если файл не находится, вполне вероятно, что база данных файлов устарела, тогда поможет команда updatedb.

Cockpit
=======

штука для удаленного мониторинга.

[https://cockpit-project.org/running](https://www.google.com/url?q=https://cockpit-project.org/running&sa=D&source=editors&ust=1662229049530269&usg=AOvVaw1rwlFY9JL9iytzVuXoFJdH)

для RHEL 7  
sudo subscription-manager repos --enable rhel-7-server-extras-rpms

для RHEL 8 не нужно прописывать репозиторий

sudo yum install cockpit Установка

Запуск и проверка

###### sudo systemctl enable --now cockpit.socket

sudo systemctl status cockpit.socket

Если прописаны не стандартные правила firewall  
sudo firewall-cmd --add-service=cockpit

sudo firewall-cmd --add-service=cockpit --permanent

![](images/image82.png)

Midnight Comander
=================

Ctrs + s  Быстрый поиск в текущей директории

Alt + e  Кодировка

* выделить по паттерну

        В диалоге поиска можно искать по истории Ctrl + UP, Ctrl + Down

\           убрать выделение по паттерну

alt + *   инвертировать выделение

alt + i    отобразить текущую директорию на другой панели

alt + u   alt + y  ходим по каталогам в истории

можно запустить  mc без всяких цветов. mc - b

F3 смотреть файл

F4 редактировать файл. Обычно открывается vim

Shift F4 создать новый файл

Alt + Enter Внести текущий выделенный обьект в командную строку

Alt + a Внести путь до текущей панели в комадную строку

alt + c быстрый переход cd из текущей панели. Увы без подсказок TAB

alt + o  Открываем выделеную директорию в другой панели. Удобная штука

alt + n, alt + p = ходим по истории команд в командной строке

alt + t  меняем вид панели. Полный, короткий, длинный

alt + shift + h - Показать историю директорий

alt + shift + ?   Диалог поиска

ctrl + o   Скрыть панели показать

Ctrl-R -- Refresh directory

alt + . Показывать скрывать все скрытые файлы

alt + , Горизонтальный вертикальный режим

F9 - Выделить строчку меню

Иногда пересекаются команды окна и комадной строки или внешней оболочки. Для экранирования используется клавиша Esc.

Ctrl-x q.   Режим просмотра файлов. Справа панель, слева текст.

КАк нажимать!!   Сначала ctrl + x   потом отпускаем обе и нажимаем q

Избранные директории в mc

Добавить директорию  Ctrl + x, h

Открыть список ctrl + \

Часто необходимо поменять цветовую схему

Готовые темы оформления (skins) после установки Midnight Commander располагаются по пути:

~|⇒ ll /usr/share/mc/skins

Туда можно заглянуть и выбрать, что понравиться:

~|⇒ ll /usr/share/mc/skins  
total 212K  
-rw-r--r-- 1 root root 3,0K Dec  5  2013 darkfar.ini  
-rw-r--r-- 1 root root 3,0K Dec  5  2013 dark.ini  
-rw-r--r-- 1 root root 2,7K Dec  5  2013 default.ini  
и тд

некоторые темы используют 256 цветов. Для переключеия в этот режим достаточно поместить этот срипт в .bashrc

|     |     |
| --- | --- |
| \# Some terminal games can't handle 256 color TERM types |     |
|     | \# Can't use screen-256color because it conflicts with some |
|     | \# window tab settings. |
|     | \# Can't use putty-256color because MoTTY (PuTTY) is in xterm |
|     | \# mode. |
|     | \# Since MXT always runs a login shell for anything run from |
|     | \# the menu, select TERM based on the command run. |
|     |     |
|     | case"$BASH\_EXECUTION\_STRING"in |
|     |     |
|     | *ctris*) TERM=xterm;; |
|     | *ninvaders*) TERM=xterm;; |
|     | *) TERM=xterm-256color;; |
|     | esac |
|     |     |
|     | export TERM |

Всё, можно использовать указывая тему явно:

$\> mc -S xoria256

Либо указав новую тему в файле ~/.mc/ini

$\> mcedit ~/.mc/ini

Найдите внутри строку вида «skin=default» и замените на «skin=xoria256»

НО это делать нужно не запуская mc, иначе тема будет перетираться на дефолтную

Если используем cygwin , то удобно, чтобы файлы открывались многие также как и в windows. Для этого находим /etc/mc/mc.ext

там прописаны правила для различных расширений.

В конце есть секция ее заполняем так

default/*

        Open=cygstart %p

        View=

Если выше уже указано правило по работе с расширением и нам оно не подходит просто комментируем его и будет запускаться дефолтная программа

Linux comm
==========

The 'comm' command compares two files or streams. By default, 'comm' will always display three columns. First column indicates non-matching items of first file, second column indicates non-matching items of second file, and third column indicates matching items of both the files. Both the files has to be in sorted order for 'comm' command to be executed.

Syntax:

1.  comm &lt;file1&gt;&lt;file2&gt;

Example:

1.  comm file1.txt file2.txt  

![Linux Comm Filter1](images/image379.png)

Look at the above snapshot,

First column displays non-matching items of first file 'file1.txt'        (Sehwag, Yuvi)

Second column displays non-matching items of second file 'file2.txt'        (Zadeja)

Third column indicates matching items of both the files        (Dhoni, Dravid, Sachin)

* * *

To Display Single Column
------------------------

If you want to output a single column, you have to specify number of the columns which are not to be displayed.

Syntax:

comm -23 (To display first column)

comm -13 (To display second column)

comm -12 (To display third column)

Example:

comm -23 file1.txt file2.txt

comm -13 file1.txt file2.txt

comm -12 file1.txt file2.txt

![Linux Comm Filter2](images/image276.png)

Look at the above snapshot, column number which needs to be displayed are not mentioned in the 'comm' command.

Linux tee
=========

The 'tee' command is similar to 'cat' command with only one difference. It puts stdin on stdout and also put them into a file.

Syntax:

1.  cat or tac &lt;fileName&gt;| tee &lt;newFile&gt; |  cat or tac |.....  

Example:

1.  tac weeks.txt | tee new.txt | cat  

![Linux tee Filters](images/image447.png)

Look at the above screenshot, file 'new.txt' is created with the help of'tee'command.

Linux uniq
==========

With the help of uniq command you can form a sorted list in which every word will occur only once.

Syntax:

1.  command &lt;fileName&gt; | uniq  

Example:

1.  sort dupli.txt | uniq  

![Linux Uniq Filters1](images/image55.png)

Look at the above snapshot, words which are repeating, repeats only once with the 'uniq' command.

* * *

uniq -c
-------

You can count the number of occurences of a word with 'uniq -c' command.

Syntax:

1.  command &lt;fileName&gt; | uniq -c  

Example:

1.  sort dupli.txt | uniq -c  

![Linux Uniq Filters2](images/image394.png)

Look at the above snapshot, command "sort dupli.txt | uniq -c" counts the number of times a word is repeating.

Open SUSE

Настроить прокси

 /etc/syconfig/proxy  

HTTP_PROXY="http://myusername:mypassword@myproxy.example.com:8080"

Подключить общую папку

sudo mount -t vboxsf wd ~/host

Запуск процессов по расписанию
==============================

Существует 3 способа. Cron (самый мощный и разнообразный) at (запуск один раз) и systemd timers (современный способ)

Cron
----

Добавить правило для текущего пользователя crontab -e

Посмотреть для текущего пользователяcrontab -l

Вышестоящими командами правила добавляются в файл

/var/spool/cron/%username%. Но посмотреть явно этот файл может только root

Для всей системы создаем файл в каталоге /etc/cron.d

![](images/image440.png)

тут могут лежать файлы со стандартными названиями hourly, daily, weekly, а также другие файлы с произвольными правилами

![](images/image201.png)

Кроме cron.d существуют и другие каталоги для помещения правил. Их названия говорят сами за себя. В этих папках могут располагаться скрипты, которые будут запускаться в соответствии с временным интервалом названия папки. Правила прописывать не нужно, достаточно поместить скрипт файл в папку.

![](images/image73.png)

Также существует устаревший способ, добавление в /etc/crontab

За запуск скриптов из папок cron.(периодичность) отвечает anacron, конфигурация которого в /etc/anacrontab. Тут важно заметить, что в anacrontab конфигурируется запускаемость скриптов из папок cron.weekly, cron.monthly, cron.daily, но не cron.hourly. За hourly отвечает скпипт 0hourly в каталоге /etc/crod.d.

\* \* \* \* \*    минута, час, день, месяц, день недели. Если все оставить звездочками, то значит каждую минуту.

Могут быть и противоречивые записи.

*/10 4 11 12 1-5    Каждые 10 минут, 4 час,  11 день месяца, 12 декабрь. 1-5 по будням. Будет выполняться только в декабре, 11 числа и по-будням каждые 10 минут.

Скрипты не должны писать в stdout, команда упадет, если попробует писать в stdout. Следовательно нельзя, к примеру, использовать команду echo. Необходимо писать в syslog.

Пример:

Посмотрим на дату:

![](images/image90.png)

Для текущего пользователя заведем правило, чтобы каждую минуту в syslog писалось Good day. А также сделаем это и для root

![](images/image171.png)

![](images/image271.png)

![](images/image313.png)

Иногда бывает трудно вспомнить правила cron .

Полезна команда man 5 crontab

Для того, чтобы запустить автоматически скрипт после перезагрузки

в каталоге /etc/cron.d делаем файл

@reboot   root        /home/osboxes/scripts/antscript

at
--

Для запуск однократно команды в определенное время существует сервис atd.

at &lt;time&gt; запланировать job. При этом открыватеся интерактивный shell, куда можно вписать одну или несколько команд. Чтобы выйти нужно нажать Ctrl D

При этом сервис atd должен быть запущен.

![](images/image101.png)

![](images/image324.png)

atq  вывести список запланированных джобов

![](images/image61.png)

atrm  удалить джобу

![](images/image269.png)

systemd-tmpfiles
----------------

В каталоге /etc/lib/tmpfiles.d находятся настройки создания, удаления и очистки временных файлов

systemd-tmpfiles-clean.timerЮнит, который может быть настроен для удаления временных файлов. Он запускает systemd-tmpfiles-clean.service.Сервис определяет что делать, таймер определят когда делать. Сервис запускает команду, которую можно выполнить и напрямую  systemd-tmpfiles --clean

systemctl cat systemd-tmpfiles-clean.timer Настройки таймера

![](images/image2.png)

Тут видим, что таймер стартует через 15 минут после старта. Период между запусками 1 день.

В файле /usr/lib/tmpfiles.d/tmp.confнаходятся настройки автоматического удаления файлов из директории /tmp

Рекомендуется для того, чтобы правила применились для всей системы после изменений в файле /usr/lib/tmpfiles.d/tmp.confскопировать его в /etc/tmpfiles.d/tmp.confПосле правки этого файла его можно проверить на корректность, выполнив команду

systemd-tmpfiles --clean /etc/tmpfiles.d/tmp.conf

В файле tmp.conf располагаются настройки: какие директории мониторить, какие права доступа установлены на эти директории, какой пользователь является владельцем файлов, сколько дней файлы будут жить прежде чем будут удалены. Для помощи существует стриничка помощи man tmpfiles.d

![](images/image393.png)

![](images/image210.png)

Создадим кастомную конфигурацию.

![](images/image15.png)

![](images/image91.png)

![](images/image370.png)

Видим, что файл все еще остался. А все потому, что таймер включен, но настроено в нем, что запускается он раз в день.

Можно вызвать команду напрямую.

![](images/image110.png)

Команды времени
===============

![Linux Locate](images/image81.png)

dateОтображает текущую дату

![Linux Date1](images/image129.png)

также можно описать формат, в котором отображать дату

![Linux Date2](images/image169.png)

calОтображает календарь

![Linux cal1](images/image400.png)

cal &lt;month&gt;&lt;year&gt;

![Linux cal2](images/image103.png)

sleep 5 Команда заставляет терминал остановиться на определенное время. По-умолчанию в секундах.

![Linux Sleep](images/image158.png)

timeКоманда показывает, как долго работают другие команды

more - просмотр наподобие cat , но с постраничным просмотром

type  Показывает тип команды. В Linux существует четыре типа команд:

* запускаемые файлы
* команды встроенные в shell
* shell function
* alias

zless Открыть текстовый файл упакованный gzip.   .gz

![Linux Time](images/image229.png)

Virtual Box
===========

mnt дисков
----------

Возникли сложности при маунте дисков внутрь Ubuntu Server.. Проблема была в том, что обязателен GuestAddition.iso , но он почему не применялся при добавлении, пришлось искать решение, вот оно:

If you don't download the ISO, you won't get the "latest and greatest" version. If you'd like to stick with this option, please [see the following notes for dependencies](https://www.google.com/url?q=https://gist.github.com/magnetikonline/1e7e2dbd1b288fecf090f1ef12f0c80b&sa=D&source=editors&ust=1662229049553849&usg=AOvVaw2o2USLdtF1wF6hBYlYS4aO).

I have tested these instructions successfully under an Ubuntu 16.04 guest:

1.  Create Ubuntu server instance under VirtualBox (obviously).
2.  Start VM, go to Devices -\> Insert Guest Additions CD image to mount the ISO image.
3.  From the terminal, run the following commands:  
    sudo -i apt install gcc make mkdir -p /media/cdrom mount /dev/cdrom /media/cdrom /media/cdrom/VBoxLinuxAdditions.run reboot
4.  After reboot:  
    sudo usermod --append --groups vboxsf USERNAME
5.  Host shares should now be mounted in Ubuntu guest under /media via the installed VBoxService service, set to start on system boot-up.

This impacted my install.

Noted from comment:

* Log out and back in again after adding user account to vboxsf group

Настройка сети

в режиме NAT. Извне из локальной сети пробиться к виртуалке будет невозможно, зато из виртуалки можно проходить во внешнюю сеть. Более того из системы хоста можно заходить на виртуальную машину через ssh ,  для этого необходимо настроить проброс портов

![](images/image449.png)

Удобнее всего настроить в режиме Bridge. Когда вируальная машина регистрируется в локальной сети через DHCP роутера и является полноправным участником сети ( не только хостовая система может заходить на виртуалку и проброс портов настраивать не нужно)

![](images/image197.png)

[https://techlist.top/virtualbox-network-settings-part-1/](https://www.google.com/url?q=https://techlist.top/virtualbox-network-settings-part-1/&sa=D&source=editors&ust=1662229049555646&usg=AOvVaw0h_78D0X_G2L5uzVpGHz_D)

CentoOS VirtualBoxGuest

[https://linuxconfig.org/virtualbox-install-guest-additions-on-redhat-8](https://www.google.com/url?q=https://linuxconfig.org/virtualbox-install-guest-additions-on-redhat-8&sa=D&source=editors&ust=1662229049556025&usg=AOvVaw3BWyFTUy2tkU5JnUrHBTFX)

Вызываем эту команду

root@osboxes:/home/dima# lsblk

NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT

loop0    7:0    0 86.9M  1 loop /snap/core/4917

loop1    7:1    0 87.9M  1 loop /snap/core/5662

sda      8:0    0  500G  0 disk

├─sda1   8:1    0    1M  0 part

├─sda2   8:2    0  200G  0 part /

├─sda3   8:3    0    5G  0 part /boot

├─sda4   8:4    0    6G  0 part \[SWAP\]

└─sda5   8:5    0  289G  0 part /home

sr0     11:0    1 1024M  0 rom

root@osboxes:/home/dima#

далее находим UUID для нужного диска посредством команды

Смотрим все разделы файловой системы.

sudo blkid

Создадим каталоги для монтирования

sudo mkdir /mnt/С /mnt/D

Открываем от имени администратора файл /etc/fstab, содержащий информацию о всех монтируемых при загрузке разделах:

sudo vim /etc/fstab

Добавляем в конец файла,

для NTFS:

UUID="7ECCC7F5CCC7A62D" /mnt/Shared ntfs rw,nls=utf8,gid=plugdev,umask=0002 0 0

для FAT и FAT32:

UUID="355B-FE37" /mnt/TrendNet8Gb vfat rw,exec,codepage=866,nls=utf8,gid=plugdev,umask=0002,nofail,users 0 0

Монтируем только что вписанные разделы диска:

sudo mount -a

Расширения дискового пространтсва

Возникли сложности с расширением

![](images/image318.png)пришлось делать так.

![](images/image113.png)

.\\VBoxManage.exe clonehd "F:\\Master\\VirtialMachine\\cent8\\cent8.vdi" "F:\\Master\\VirtialMachine\\cent8\\cent82.vdi"  --format VDI

 .\\VBoxManage.exe modifyhd  "F:\\Master\\VirtialMachine\\cent8\\cent82.vdi"  --resize 40999

Операции с правами
==================

File Permission
---------------

Все файлы в Linux имеют три типа permissions: чтение, запись, запуск. Также permissions бывают трех типов: для владельца, для группы владельцев, и всех остальных пользователей. Можно увидеть исполнив команду ls -l

|     |     |
| --- | --- |
| 1  <br>2  <br>3 | drwxr-xr-x 2 username username       4.0K 2009-08-13 10:16 docs  <br>-rw-r--r-- 1 username username       8.1K 2009-07-09 16:23 roster.py  <br>lrwxrwxrwx 2 username username       4.0K 2009-08-13 10:16 team.docs |

Тут видим -d директория -l symbolic link. Далее разрешения для владельца, для группы владельцев и всех остальных

chown user \[:group\] file  Изменить владельца , группу владельцев у файла.

chown anna:profs file  Изменяем владельца на anna и группу profs

Если хотим поменять только группу владельцев.

chgrp group\_name file\_name

![](images/image56.png)

chmod Используется в двух режимах.

Абсолютный: chmod 750 my_file

Относительный:  chmod +x my_script Устанавливаем права на запуск

В этом режиме права доступа задаются так chmod &lt;group&gt;&lt;operator&gt;&lt;permission&gt;

Если &lt;group&gt; не указываем считается, что имеем ввиду пользователя владельца

![](images/image286.png)

![](images/image190.png)

Абсолютный. Права доступа представляют собой три восьмеричных числа.

например chmod 755 my_script

![](images/image336.png)

umask
-----

Начальные права доступа для файла 666, для директории 777.

Понятие umask это тоже 3 цифры, которые отнимаются от начальных прав доступа.

Если поставим umask 022. При создании новых файлов права доступа будут 644, для директорий 755.

Задается для всех пользователей в файле /etc/profile

Для конкретного пользователя можно поменять в ~/.bash_profile

Также можно поставить для текущей сессии через umask &lt;value&gt;

Специальные права доступа
-------------------------

Существуют три специальных права доступа: SUID (Set User id) , SGID(Set group id), Sticky bit

![](images/image117.png)

Для установку SUID

chmod 4770 your\_file      chmod u+s your\_file

Это очень вредная и опасная штука. При установке права доступа SUID любой пользователь будет запускать файл как владелец этого файла. Обычно такие файлы подкрашиваются красным, чтобы отобразить, что операции могут быть крайне опасными.

![](images/image424.png)

какие файлы в нашей имеют права доступа SUID

find / -perm /4000 2>/dev/null

### GIUD

Для установки chmod 2770 your\_directory      chmod g+s your\_directory

Удобно использовать, когда необходимо чтобы файлы создаваемые в директории членом группы устанавливали группу не пользователя, а определенную.

Пример:

1.  Создадим директори profs в каталоге /tmp из под root. Далее изменим group owner на profs. И выдадим 770 права для группы. Цель в том, что дать права пользователям profs заходить в директорию  создавать там файлы

![](images/image272.png)

2) Убедимся, что в группу profs входят два пользователя.

![](images/image319.png)

3) Залогинемся под anna и создадим файл в директории profs

![](images/image244.png)

Увидим, что группа прописалась как anna , т.к primary группа у пользователя anna это anna. Для того, чтобы дать права на запись другим членам группы profs, необходимо менять через chown для этого файла группу. И для всех последующих файлов, создаваемых пользователем anna. НО есть другой способ.

![](images/image66.png)

Теперь в группе прав доступа для группы появилась буква s, что значит SGID право доступа. Теперь при создании новых файлов, группа у файлов будет проставляться такой же как и у директории.

![](images/image257.png)

это значит, что все пользователя группы profs теперь имеют доступ на чтение и запись в файлы, создаваемые anna.

### Sticky bit

Для установки chmod 1770 your\_directory      chmod +t your\_directory

Создает право доступа на удаление файла только для его владельца и для владельца директории.

Увидим, что пользователь audrey входит в группу profs и имеет права на запись(т.е и на удаление) файлов в директории /tmp/profs

![](images/image176.png)

![](images/image374.png)

зайдем в директорию и удалим файл, созданный пользователем anna

![](images/image410.png)

Иногда может быть полезным ограничение на удаление только теми пользователями, которые непосредственно создавали файл.

![](images/image228.png)

ACL (Access Control List)
-------------------------

Для более расширенного управления правами доступа применяются ACL. Например, у файл может принадлежать сразу нескольким группам пользователей, с различными правами доступа.

Есть два вида ACL

* normal ACL. Правила ACL применяются к уже существующим файлам и директориям. К новым файлам и директориям правила не применяются
* default ACL. Применяются ко всем новым файла и директориям.

Рекомендовано сразу устанавливать ACL к новой директории.

getfacl &lt;file\_or\_directory&gt; Получить информацию о ACL у файла или директории

setfacl -R -m g:&lt;name\_of\_group&gt;:&lt;permissona&gt; &lt;directory&gt;Установить правило

-R  флаг рекурсивности по всем файлам внутри директории

-m modified

\- g группа

setfacl -m d:g:&lt;name\_of\_group&gt;:&lt;permissona&gt; &lt;directory&gt;Установить правило (default ACL). Как сказано выше, это правило будет применяться для всех новых файлов внутри директории

Пример:

Создадим две группы accounts и sales. Далее создадим директории accounts

![](images/image367.png)

ПРОБЛЕМА. Как без изменения прав доступа others дать права группе accounts на чтение файлов в директории sales?

Получим данные acl. Видим, что информация предоставляется даже если никаких правил ACL еще не было установлено.

![](images/image204.png)

setfacl -m d:g:accounts:rx sales

Применили default ACL , т.к никаких файлов в директории нет. Видим, что добавился + рядом с правами доступа к директории sales

![](images/image332.png)

![](images/image40.png)

Создадим файл внутри директории и убедимся, что правило ACL применилось.

![](images/image143.png)

Видим сообще о реально действующих правах доступа. Даже если в правилах ACL мы указывали rx для группы accounts. Реально работать будет только x из-за политики Lunix, которая запрещает делать файлы запускаемыми по-умолчанию.

Создадим директорию 2020 внутри sales. А также еще одну директорию внутри 2020 и увидим, что правила ACL наследуются рекурсивно.

![](images/image290.png)

![](images/image136.png)

Примеры сложностей понимания прав доступа
-----------------------------------------

### Удаление файла

создадим в каталоге /home/anna файл из под root

![](images/image128.png)

Может ли anna удалить этот файл? С одной точки зрения нет, т.к она не является владельцем файле, не входит в группу root. А для всех остальных описано право доступа только на чтение.

НО можно. Почему. Да потому, что на папке /home/anna установлены следующие права. Видим что anna является владельцем и у не владельца есть права на запись, значит и на удаление.

![](images/image371.png)

### Запись в файл

создадим в каталоге /home/anna файл из под root

![](images/image128.png)

Может ли anna записать в этот файл? Ответ нет. Но бывают странные случаи.

Откроем vim и попытаемся отредактировать файл.

![](images/image236.png)

Vim предупреждает нас, что файл только для редактирования. Но мы все равно продолжим, поменяем файл и выйдем :wq!

![](images/image402.png)

Vim удалил старый файл и создал новый от имени anna.

### Смена прав доступа

создадим файл new_file из под root в /home/anna

Сменим владельца и группу на anna. Затем поставим права доступа 006.

![](images/image167.png)

Может ли анна посмотреть этот файл? Нт. Т.к у владельца нету прав доступа на чтение.

НО т .к anna является владельцем файла она может изменять права доступа.

![](images/image358.png)

Операции с пользователями
=========================

su - &lt;username&gt;Команда позволяет запустить shell другого пользователя

Рекомендуется всегда писать -

![Linux su Commands1](images/image303.png)

su - Зайти под root. Рекомендуется всегда писать - ,

Когда закончили работать из под root , можно существует команда exit, которая выходит из под рута к обычному пользователю

![](images/image116.png)

whoami Показывает имя пользователя

Выполнять команды администратора рекомендуется не заходя в сессию root , а исполняя команды через sudo.

Политика использования sudo определяется в файле /etc/sudoerr и сприптами в каталоге /etc/sudoerr.d. Рекомендуется явно не редактировать эти файлы, а использовать утилиту visudo

ВАЖНО. Иногда не видно, что в sudoerrs и через visudo пользователю установлена группа wheel или явно прописано что для пользователя разрешены все права. Запросто может быть скрипт в каталоге /etc/sudoers.d где будет одна строчка. Например:

![](images/image442.png)

Важные секции в файле:

для группы wheel разрешены все команды

![](images/image253.png)

есть и опасная строчка, можно разрешить группе исполнять все права без ввода пароля. По-умолчанию она закоментирована

![](images/image179.png)

Вот-так выдадим права пользователю исполнять команды добавления пользователя и смены пароля со всех компьютеров

![](images/image250.png)

![Linux Introduction To Users1](images/image441.png)

who Показывает кто залогинен в системе

![Linux Introduction To Users2](images/image21.png)

w Показывает кто сейчас залогинен  в системе и что он делает

![Linux Introduction To Users4](images/image54.png)

id Показывает user id, primary group id, и лист групп, в которых находится пользователь

![](images/image340.png)

у пользователя видно, что группы суперпользователя у юзера нет (wheel).

usermod Меняет существующие атрибуты пользователя

usermod -c &lt;'newName'&gt; &lt;oldName&gt;   изменение имени

usermod -c 'jhonny' john  

![Linux Local User Management6](images/image247.png)

usermod -aG wheel student добавить пользователя student в группу wheel

![](images/image299.png)

для того, чтобы изменения увидел сам пользователь, пользователю необходимо войти заново в систему!!

Свойства пользователя
---------------------

У каждого поля есть обязательные свойства. Рассмотрим на примере свойств описанных в /etc/passwd

![](images/image219.png)

* имя пользователя
* пароль. В файле passwd он указан как x, который на самом деле placeholder. Пароли хранятся в зашифрованном виде в shadow файлах
* UID. Уникальный ID пользователя
* Group ID. ID группы пользователя. Каждый пользователь должен быть членом хотя бы одной группы. При создании пользователя автоматически создается группа с именем пользователя. Т.е он всегда будет находится минимум в одной группе - с тем же названием, что и имя пользователя.
* GECOS. Дополнительная информация в виде строки, не обязательное свойство
* Домашная директория. По-умолчанию пользователь может создавать файлы только в домашней директории и каталоге /tmp
* Shell. Дефолтный shell, который запускаетс при входе пользователя.

useradd -m &lt;userName&gt;  

![Linux Local User Management3](images/image323.png)

-m создать домашнюю директорию

-d задать имя домашней директории

-с установить комментарий к пользователю (GECOS)

useradd -D Посмотреть дефолтовые значения, с которыми создаются пользователи. Они располагаются в файле /etc/defaults/useradd

![Linux Local User Management4](images/image411.png)

а также в файле /etc/login.defs. В нем настройки длительности действия пароля, минимальное кол-во символов в пароле, диапазоны id системных и персональных пользователей, метод шифования паролей.

![](images/image237.png)

![](images/image130.png)

userdel -r &lt;userName&gt;  удалить пользователя

![Linux Local User Management5](images/image184.png)

passwd   сменить текущий пароль текущего юзера

passwd &lt;userName&gt;   из под root можно менять пароль любого юзера

passwd -l &lt;userName&gt;   заблокировать пользователя

также можно это сделать командой usermod -L &lt;userName&gt;  

при этом в файле с хешами паролей появится ! знак перед хешом.

passwd -u &lt;userName&gt;   разблокировать пользователя

или usermod -U &lt;userName&gt;

При этом знак ! перед паролей удалиться. Можно это и руками делать, но считается плохой практикой.

В каталоге /etc/skel/ содержат дефолтный скрытые файлы.Когда добавляем пользователя через useradd -m option, /etc/skel/ копируется в домашнюю директорию пользователя

![Linux Local User Management7](images/image94.png)

Пароли хранятся в зашифрованном виде в /etc/shadow

![Linux User Password3](images/image104.png)

Колонки:

* имя пользователя
* хеш пароля
* время начала действия пароля в днях с 1970 года
* минимальное кол-во дней действия пароля
* максимальное кол-во дней действия пароля
* период в течении которого пользователю будет выдаваться предупреждения о скором истечении срока действия пароля.

Группы пользователей хранятся в файле /etc/group

В ней указаны имя группы, id группы и список пользователей, входящих в группу. В /etc/passwd также указывается id группы, но там так называемые primary group. В etc/group secondary группы

![](images/image315.png).

Операции с группами
===================

groupadd &lt;name_group&gt; Создание новой группы

groupmod &lt;name_group&gt; Модификация группы (используется редко)

groupdel &lt;name_group&gt; Удаление группы

lid -g &lt;name_group&gt; Показать всех пользователей входящих в группу

Сеть
====

ip addr show Показать список сетевых интерфейсов и их сетевые адреса

ранее эту информацию обычно получали через ifconfig

![](images/image426.png)

ip link Показать список сетевых интерфейсов

![](images/image437.png)

похожая команда, но со статистикой по сетевым интерфейсам ip -s link show

![](images/image293.png)

ip addr add dev &lt;name\_of\_interface&gt; &lt;ip\_with\_submask&gt; Добавить еще один ip на сетевой интерфейс

![](images/image305.png)

ip route showПоказать список роутеров (gataways)

![](images/image85.png)

ip route del default via 192.168.100.1 Удалить шлюз

ip route add default via 192.168.100.1 Добавить шлюз

![](images/image320.png)

cat /etc/resolv.conf Посмотреть dns сервер

![](images/image376.png)

Этот файл автоматически создается NetworkManager при перезагрузке.

NMCLI (Network Manager command line interface)
----------------------------------------------

Утилита для конфигурации сетевых интерфейсов.

Для работы с этой утилитой необходимо проверить несколько аспектов

Проверка статуса запуска NetworkManager

systemctl status NetworkManager

![](images/image404.png)

проверка наличия пакета bash-completion

Arpm -qa | grep bash-completion

![](images/image445.png)

### Создание новой конфигурации подключения

Тут нужно пользоваться частым TAB, т.к команды длинные

nmcli connection add ipv4.addresses 192.168.100.11/24 ipv4.gateway 192.168.100.1 ipv4.dns 8.8.8.8 type ethernet ifname enp0s3

![](images/image383.png)

nmcli connection showпосмотреть список соединений

![](images/image105.png)

видим, что новое соединение не активно.

nmcli connection up &lt;name_connection&gt; сделать соединение активным

![](images/image238.png)

nmtui (Network Manager text user interface)
-------------------------------------------

Более легковесная утилита чем nmcli для конфигурации сетевых подключений.Запускается из консоли.

![](images/image146.png)

Расположение файлов конфигураций сетевых интфейсов
--------------------------------------------------

Network Manager сервис отвечает за создание и модификацию конфигурация для сетевых интерфейсов. В RHEL 8 они располагаются в

/etc/sysconfig/network-scripts

![](images/image388.png)

В них стоит смотреть, если конфигурация сетевых интерфейсов через nmcli и nmtui завершилась неудачно. После измененения конфигурация для их применения нужно выполнить nmcli connection up &lt;name_connection&gt;, либо перезагрузить систему, либо перестартовать networkmanager

![](images/image321.png)

![](images/image206.png)

Проверка сетевого соединения
----------------------------

ping &lt;url&gt; самая простая команда для проверки соединения

![](images/image50.png)

Прервать команду можно через Ctrl + C

Иногда использовать в скриптах, строгое числов пингов ping -c 1 google.com

Также иногда полезна опция ping -f google.com. Отправляет так много пакетов как может и далее показывает статистику. Удобно для проверки сети.

Описание выше ip addr show, ip route show

dig &lt;url&gt; команда для проверки dns

![](images/image193.png)Управление процессами
=============================================

Любую команду, которую запускаем из shell будем называть job.

command & запустить command в фоновом режиме

Если предыдущая джоба запускалась не в фоновом режиме. Можно ее остановиться через Ctrl + Z и затем написать bg для запуска в фоновом режиме.

Чтобы посмотреть джобы используем команду jobs

![](images/image353.png)

Также джобу можно перевести из фонового режима в активный командой fg &lt;N&gt;, где N - номер джобы в списке джобов

ps aux Посмотреть все процессы. Возможны два стиля, без дефиса это BSD стиль, с дефисом это System5 стиль. Пошло с середины 70-x, т.к было две разных UNIX системы.

![](images/image13.png)

Тут колонки. PID - process ID(id процесса) , утилизация процессора, памяти, виртуальной памяти, остаток памяти, tty терминал, в котором запустился процесс, если ? то это значит процесс в фоновом режиме. Далее статус. Дата старта и время работы процесса. Также команда, ассоциированная с процессом.

Процесс с PID это systemd.

Процессы с командой в квадратных скобках это процессы ядра.

Процессы отсортированы по вреени старта. Т.е самые новые процессы будут внизу,  в том числе и сам ps aux.

![](images/image275.png)

ps -fax Процессы в иерархии. Показывает отношения между родительским и дочерними процессами. Тут есть фишка. Если остановить родительский процесс, все его дочерние также остановятся.

![](images/image96.png)

ps -fU &lt;user&gt; Посмотреть процессы пользователя

ps -f --forest -C &lt;process&gt; Посмотреть дерево определенного процесса

![](images/image8.png)

ps -LПосмотреть возможные спецификаторы процессов. Им около 200 штук

Зная эти спецификаторы, можно отображать только определенные свойства процессов командой ps -eo &lt;спецификатор, спецификатор&gt;

Например, отобразим команду и id процесса

ps -eo pid, cmd

![](images/image443.png)

Сигналы
-------

Страница помощи по сигналам man 7 signal

![](images/image249.png)

Остановить процесс можно через kill &lt;pid&gt; , а также через k из команды top

а также

pkill &lt;name&gt;

killall &lt;name&gt;

Приоритеты

Тот процесс, который приоритетнее получает больше процессорного времени. Приоритет изменяется от самого высокого -20 до самого низкого 19.

Еще выше процессы ядра с приоритетом rt (runtime)

Через top командой r, можно поменять приоритет у процесса.

Тут важно помнить, что указываем приращение к текущему приоритету. -20, будет означать вычесть из текущего приорита 20 . Если был приоритет 20, он танет 0, т.е приоритет повысится. На картинке видны одинаковые процессы, но у одного приоритет 0 и он загружает почти весь процессор. Если приоритеты одинаковые процессу будут получить одинаковое время процессора.

![](images/image86.png)

А также

renice -n &lt;value&gt; &lt;pid&gt; где после n указывается приращение приоритета.

Можно запустить процесс уже с приоритетом nice -n &lt;value&gt; &lt;command&gt;

Профилирование системы
----------------------

Сервис tuned призван применять к системе различные профили производительности.

tuned-adm list Показать список профилей

![](images/image243.png)

tuned-adm active Показать активный профиль (list его тоже отображает)

![](images/image378.png)

tuned-adm profile &lt;name_profile&gt; Активировать профиль

![](images/image155.png)

RPM(Red Hat Package Manager)
============================

В состав пакета rpm входит сжатые файлы сpio, метаданные, а также список зависимостей пакета. Пакет также может содержать и скрипты.

Для установки пакетов используются репозитории. Можно поставить пакет и самостоятельно, но это не рекомендуется, т.к в этом случае не будут проверены зависимости пакета. При установке из репозитория зависимости обязательно проверяются. В RHEL 8 введены разделены репозитории на два типа. Application stream (appstream) для пакетов приложений и baseOS для пакетов операционной системы.

Путь к репозитории в RHEL добавляются как файл в каталог /etc/yum.repos.d

![](images/image432.png)

yum repolistПоказать список подключенных репозиториев

![](images/image49.png)

AppStrem делится на два типа составляющих: стандартные rpm пакеты и модули. Модули содержат streams (версии) для возможности иметь несколько версий приложений. Модули также содержат профили (profiles) Профиль это список пакетов для определенных целей, например minimal, default, extended. Модуль может ссылаться на пакеты, которые не находятся непосредственно в каком-то из его stream.

Пакеты
------

yum search &lt;name&gt; Поиск пакета в репозиториях

![](images/image362.png)

yum provides &lt;name&gt; Более глубокий поиск. Поддерживает паттерны и ищет по файлам внутри пакетов и в их описаниях

yum install &lt;name&gt; Установить пакет

![](images/image145.png)

yum remove &lt;name&gt; Удалить пакет

Пакеты могут быть защищены от удаления, например при удалении vi будет выведено сообщение, что пакет защищен.+

yum update &lt;name&gt; Обновить пакет и его зависимости. Если не указываем name значит обновляем все пакеты.

yum info &lt;name&gt; Детальная информаци о пакете

![](images/image355.png)

yum list &lt;all, installed&gt; Список пакетов.

  
rpm -qf &lt;file_name&gt;Понять в каком пакете находился тот или иной файл

например

rpm -qf /etc/tcsd.conf.

Видим некий конфиг. Получаем информацию из какого пакета он установлен. Потом смотрим на список файлов в пакете. Потом можем запросить инфо о пакете.

![](images/image37.png)

rpm -ql &lt;name&gt;Список файлов в пакете

rpm -qс &lt;name&gt;Список конфигурационных файлов в пакете

rpm -qd &lt;name&gt;Список файлов документации в пакете

rpm -qp --scripts &lt;name&gt;Показать содержимое скриптов в пакете

НО команды выше работают только с уже установленными пакетами. Часто бывает нужно понять, а что внутри пакета, который хотим установить, возможно там какие-то скрипты, которые нарушат работу системы, т.к установка происходит под права root.

В этом случае делаем так. Если пакета еще нет под рукой, но он есть в репозитории его можно загрузить.

Если установить пакет dnf-utils. Устанавливается утилита yumdownloader, которой можно выкачивать пакеты из репозитория без установки пакетов.

Когда пакет загружен. Добавляем опцию p в команду. Например

rpm -qpl &lt;name\_of\_package&gt; Посмотреть список файла в пакете, где name путь до пакета

![](images/image403.png)

Модули
------

yum module list Список модулей

![](images/image3.png)

yum module provides &lt;name&gt;Поиск модуля, который содержит пакет

yum module info &lt;name&gt;Информация о модуле

yum module info --profile &lt;name&gt;Поиск профилей

![](images/image382.png)

yum module list &lt;name&gt;Отображение stream внутри модуля

![](images/image316.png)

yum module install php:7.2 или yum install @php:7.2 Установить модуль

yum module install php:7.2/develУстановить профиль

Стрим (т.е версия) может быть активным или нет. Для активизации версии

yum module enable php:7.2

При установке новой версии. Предыдущий установленный стрим становиться disable.

Группы
------

Это наборы ПО, т.е наборы модулей, пакетов.

yum groups list Отображение списка групп

yum groups list hidden Отображение полного списка групп. Java отображатся тут

yum groups info &lt;groupname&gt; Отображение информации о группе

yum groups install &lt;groupname&gt; Установка группы

История изменений
-----------------

yum history Отображение списка групп

![](images/image373.png)

yum history undo &lt;number&gt; Отмена изменений из истории

Systemd
=======

Всем после загрузки ядра управляет systemd. Обьекты управления называются unitами. (mount файловых систем, устройств, старт сервисов и тд)

Для работы с systemd используется команда systemctl

systemctl-t help . Показать список типов юнитов управления.

![](images/image17.png)

systemctl list-unit-files . Показать список юнитов и их статус

![](images/image100.png)

systemctl list-units . Показать список запущенных юнитов

![](images/image407.png)

У сервиса есть статуы disabled/enabled. Показывает будет ли запущен сервис автоматически после перезагрузки

Также start / stop. Запущен ли сервис или остановлен в данный момент.

Установим сервис: sudo yum install vsftpd

systemctl status &lt;name\_of\_service&gt; . Показать статус сервиса

![](images/image57.png)

видим распложение конфигурации сервиса, также статус disabled, означающий то, что сервис не будет включен автоматически после перезагрузки. Также vendor preset - статус от автора пакета, в данном случае disabled

systemctl start &lt;name\_of\_service&gt; . Запустить сервис

![](images/image365.png)

Видим, что сервис в статусе active, т.е он сейчас работает. Но в тоже время он в статусе disabled, т.е не будет стартован после перезагрузки. Также видим PID

systemctl enable &lt;name\_of\_service&gt; . Запускать сервис после перезагрузки

![](images/image455.png)

Также можно активировать и одновременно сделать сервис enabled

systemctl enable --now &lt;name\_of\_service&gt;

Конфигурация юнитов
-------------------

/etc/lib/systemd/system. Файл с системными юнитами. Не рекомендуется трогать

/etc/systemd/system. Файл с прикладными юнитами.

/run/systemd. Файл с runtime-юнитами

Если необходимо сконфигурировать юнит, рекомендуется создавать кастомный /etc/systemd/system либо использовать утилиты

systemctl edit &lt;unit.service&gt;

systemctl cat &lt;unit.service&gt; показать настройки сервиса

![](images/image453.png)

systemctl show &lt;unit.service&gt; показать список возможных параметров для конкретного сервиса. Список большой.

![](images/image309.png)

### пример модификации конфигурации

systemctl edit vsftpdвходим в режим редактирования конфигурации. При этом создасться файл в каталоге /etc/systemd/system

Далее откроется редактор nano, куда введем следующие настройки. Они позволяют всегда перезапускать сервис через 5 секунд, если он по каким-то причина остановился

![](images/image268.png)

Сохраним файл. Далее необходимо выполнить команду

systemctl daemon-reloadДля применения изменений в конфигурациях. Далее рестартанем сервис

![](images/image44.png)

Далее убьем сервис. И увидим, что он стартует через 5 секунд.

![](images/image295.png)

Статья о том, как сделать из запускаемого jar -сервис

[https://dzone.com/articles/run-your-java-application-as-a-service-on-ubuntu](https://www.google.com/url?q=https://dzone.com/articles/run-your-java-application-as-a-service-on-ubuntu&sa=D&source=editors&ust=1662229049598142&usg=AOvVaw2xB2e_agiloAjHlMPVEsVQ)

О том как сделать Kafka сервисом

[https://www.digitalocean.com/community/tutorials/how-to-install-apache-kafka-on-ubuntu-18-04-ru](https://www.google.com/url?q=https://www.digitalocean.com/community/tutorials/how-to-install-apache-kafka-on-ubuntu-18-04-ru&sa=D&source=editors&ust=1662229049598691&usg=AOvVaw3J-7nghLhuCieocOYUQy3v)

Логирование
===========

![](images/image391.png)

Rsyslogd сервис логирования, которые существует уже очень долгое время. Обычно логи записываются в каталог /var/log, но можно настроить и другое расположение.

Так как rsyslogd является сервисом, его можно запускать и останавливать.

Начиная с RHEL7 появился systemd, который отвечает за управление сервисами. Вместе с ним появился сервис логирования journald, целью которого является сбор информации со всех сервисов systemd, теперь сервис journaldстоит в самом центре логирования системы. Управление осуществляется с помощью команды journalctl

По-умолчнанию journaldнеперсистентен. Но к счастью, существует спец файл /dev/log, который перенаправляет информацию на rsyslogd

Если этого перенаправления недостаточно, можно сделать journald персистентным, создав директорию  /var/log/journal. Далее рестартовать сервис journald или перезагрузить систему.

Rsyslogd
--------

systemctl status rsyslog.service Убедиться, что сервис запущен

![](images/image279.png)

Конфигурационный файл в /etc/syslog.conf

Вспомогательные файлы настроек в директории /etc/rsyslog.d

Каждая строчка конфигурации имеет три свойства:

1.  Facility. Цель лога. Придумана в середине 70-x и поэтому список facllity не расширяется. Пример: kern, authpriv, cron

Для сервисов, которые не имеют собственных facility существуют faclility начинающиеся с local с постфиксом от 0 до 7. В конфигурациях сервиса можно указать в какой local facility будет писать сервис. Но из-за проблемы ограничения facility многие сервисы имеют свои правила логирования и не используют rsyslog

2.  Severity. Уровень логирования. Пишется через точку после Facility
3.  Destination. Куда будет записан лог. Обычно запись лога происходит в каталог /var/log/

Для записи используется команда logger

systemd-journald
----------------

Используется также при команде systemctl status &lt;unit&gt; После статуса показываются несколько последних строк, которые записал unit в journald.

![](images/image311.png)

journalctl используется для получения информации о событиях лога. Если запустить без аргументов, отобразяться все событии с момента запуска системы.

journalctl UNIT=&lt;name\_of\_unit&gt; посмотреть логи определенного юнита

Обратить внимание, что список опций можно как обычно получить через TAB ,  а также что опции задаются с большой буквы

![](images/image53.png)

Конфигурационный файл в /etc/systemd/journald.conf

Для персистентности лога необходимо выполнить mkdir /var/log/journal

Будут создаваться файлы логов, НО эти файлы будут в бинарном формате, т.е их нельзя будет прочитать с помощью редакторов, только через journalctl.

По-умолчанию записанные логи в /run/log/journal удаляются после перезагрузки системы. Для того, чтобы отключить удаление, необходимо в  /etc/systemd/journald.conf

поменять переменную Storage.

persistent\- хранить логи в /var/log/journal если ее не существует создавать

volatile \- хранить логи только в /run/log/journal

auto\- хранить логи в /var/log/journal иначе, если ее ее не существует в /run/log/journal

По-умолчанию ротация логов настроена на месяц, а также настроены правила. Логи не могут занимать более 10% места в файловой системе, проверяется, что минимум 15% свободного места остается в системе. Эти настройки также можно изменить в конфигурационном файле.Текущее состояние этих ограничений, можно посмотреть через systemctl status systemd-journald.service

![](images/image173.png)

logrotate
---------

Запускается cron daily

Конфигурационный файл в /etc/logrotate.conf

![](images/image11.png)

Вспомогательные файлы настроек в директории /etc/logrotate.d

![](images/image409.png)

Пример

![](images/image285.png)

/proc и ядро
============

В /proc присоединена файловая система, где каждый процесс предстален как директория с PID, а также есть файлы состояний.

![](images/image39.png)

Например meminfo.

Можно наблюдать за его изменением: watch cat meminfo

![](images/image368.png)

sysctl -a выводим множественные настройки системы. Их можно поменять указав строчку в файле /etc/sysctl.conf

![](images/image205.png)

Правильным считается создание отдельного файла в директории /etc/sysctl.d

А для настроек пользователей существует спец. каталог /usr/lib/sysctl.d

![](images/image112.png)

Обновление ядра происходит всегда с сохранением старого ядра для того, чтобы иметь возможность откатиться на старое ядро. Например проприетарный драйвер может зависеть от версии ядра и при обновлении ядра драйвер, а следовательно и устройство, перестанет корректно работать.

yum update kernelили yum install kernel

Загрузка (boot)
===============

![](images/image397.png)После запуска компьютера Power-on Self Test. Самопроверка оборудования на корректность работы. Далее BIOS или UEFI, потом загрузчик GRUB, далее ядро с initramfs - временная файловая система с временной директорией и набором драйверов. После старта ядра стартует systemd, который и управляет всем. Далее base-os это устройства , далее сервисы.

В момент grub загрузчика можно нажать с далее попадаем в command mode.

В меню видим несколько вариантов

![](images/image180.png)

help выводит доступные команды

ESC выходим обратно в меню GRUB.

![](images/image248.png)

Resque режим загрузки с ограниченной функциональностью.Но цель этого режима запустить систему, если присутствуют неполадки.

e входим в расширенное меню GRUB

![](images/image80.png)

Первые строчки о загрузке видео-драйвера. Далее строки с расположением ядра. crashkernel расположение для файла дампа загрузки, если все падает его отправляем в RHEL support. Далее опция, которую можно убрать rhgb quiet - после этого при старте отображаются более детальные логи старта.

Файл конфигураций постоянных настроек GRUB /etc/default/grub

После изменений конфигураций для их применения, необходимо выполнить команду в зависимости от типа загрузчика (для проверки mount | grep efi):

для BIOS: grub2-mkconfig -o /boot/grub2/grub.cfg

для UEFI: grub2-mkconfig -o /boot/efi/EFI/redhat/grub.cfg

![](images/image196.png)![](images/image220.png)

![](images/image198.png)

Для интереса посмотрим что же это за файл, который получается после генерации

![](images/image28.png)

![](images/image405.png)

systemd target
--------------

Это набор юнитов. Некоторые из них isolatable, т.е финальные после старта системы.

emergency.target, Содержит минимальный набор сервисов на случае аварии системы

resсue.target, Также на случай аварии, но с более расширенным составом сервисов. Рекомендуется загружаться с помощью этого тартета в случае проблем, а уже потом,  если не получается загружаться в emergency target.

multi-user.target, Режим без пользовательского интерфейса

graphical.target Режим с графическим интерфейсом

Юниты как и прочие активизируеются через systemctl

Для понимания пример. Выключим любой из сервисов

![](images/image259.png)

Увидим упоминание multi-user.target

![](images/image70.png)

Посмотрим в настройки сервиса httpd. systemctl cat httpd

![](images/image458.png)

Видим секцию install с упоминанием таргета. Т.е минимальный режим, в котором запускается этот сервис это mult-user.target.

Посмотреть настройки режима systemctl cat multi-user.target

![](images/image14.png)

![](images/image223.png)

Тут не видим конкретных сервисов, которые стартуют в этом режиме. Тольки видим зависимость от basic.target. А также, что запускается этот юнит после resque.target.

Директория /etc/systemd/system

![](images/image421.png)

![](images/image140.png)

А также команда systemctl list-dependencies

Показывает режимы и их зависимости от сервисов

![](images/image255.png)

systemctl get-default Вывести текущий таргет по-умолчанию

![](images/image448.png)

systemctl set-default  &lt;target_name&gt; Установить текущий таргет по-умолчанию

![](images/image18.png)

После перезагрузки стартуем без графического интерфейса.

![](images/image138.png)

далее можем стартануть юнит графического таргета

systemctl start graphical.target

При загрузке системы в Grub меню можем нажать e и указать необходимый target для загрузки

![](images/image361.png)

Перейти из любого таргета в любой можно командой

systemctl isolate &lt;target&gt;

![](images/image264.png)

Проблемы при загрузке
---------------------

![](images/image326.png)

### Восстановление пароля root.

При старте системы, нажимаем e, входим в режим, где можно указать параметры старта

![](images/image366.png)

Необходимо найти строчку в аргументах запуска где упоминается ядро вставить в аргументы загрузки фразу rd.break

![](images/image106.png)

![](images/image181.png)

далее

Если введем mount увидим небольшое число точек монтирования, в том числе и cl-root. Оно имеет доступ только на read. Нужно поменять права на rw

mount -o remount,rw /sysroot

![](images/image114.png)

теперь если выполним опять mount увидим, что права поменялись

![](images/image35.png)

Если выполним ls увидим довольно необычную структуру директорий потому, что мы находимся в initramfs, которая доступна только в момент запуска.

![](images/image343.png)

Настоящая корневая папка root системы находится в sysroot, там же лежит и файл /etc/passwd. Для того, что сделать изменения в этом файле, выполним команду, которая изменит текущее расплоложение root директории

chroot /sysroot

![](images/image239.png)

echo &lt;password&gt; | passwd --stdin root

Вообще так делать не надо, ибо тут берется пароль из stdin и команда останется в истории. Лучше через passwd root и так далее.

![](images/image282.png)

touch /.autorelabel

Некий магический файл, который нужно создать для удовлетворения требований SELinux

![](images/image461.png)

Ctrl-D

Ctrl-D

Далее последует довольно длительная перезагрузка.

![](images/image352.png)

### Проблемы при mount во время старта

![](images/image266.png)

Bash Shell scripts
==================

Чтобы запустить скрипт, нужны права на запуск, запускаем так ./my_script.

При этом скрипт исполняется в subshell, дочерней консоли, т.е в отдельном контексте с точки зрения переменных и директорий, т.е например если делаем cd в скрипте, после завершения работы скрипта, смены текущей директории родительского shell не произойдет.

Но если запускаем вот так . my_script. это называется source - код скрипта запускается в текущей shell.

Основные конструкции

if

внутри выражение обычно используются модификации команды test. О ней можно почитать в man test![](images/image164.png)

if\[ -z $1 \]

then

 echo'there is empty argument'

 exit 6

fi

echo'hello'

Вот тут например z проверка на нулевую длину аргумента. Далее выходим exit с кодом 6. Код 0 успешно код 1 неуспешно.

Можно указать ветку else

if\[ -z $1 \]

then

 echo'there is empty argument'

 exit 6

else

 echo'hello'

fi

Чтобы вывести результат скрипта echo $?

![](images/image144.png)

![](images/image234.png)

![](images/image322.png)

Тут обратите внимание на конструкцию elif внутри if секции.

Пример с swich

![](images/image460.png)

case регистрозависимый

Перепишем в регистронезавимый вариант

![](images/image278.png)

SSH
===

![](images/image149.png)

c помощью утилиты ssh-keygen создаем два ключа, закрытый и публичный. Помещам публичный ключ в home папку на сервере. При открытии ssh сессии отправляется публичный ключ, которым сервер шифрует сообщение и отправляет на клиента. Клиент расшифровывает сообщение закрытым ключом и передает сообщение на сервер, если сообщение верное, то сервер разрешает соединение.

1.  Сгенерируем пару ключей. Можно задать пароль для ключа, так будет безопаснее, если ключ будет украден без пароля все равно не подключишься, но это не так удобно как без пароля. ssh-keygen

Создадим ключ с паролем.

![](images/image438.png)

![](images/image420.png)

в каталоге, который можно поменять при создании ключей, лежит закрытый ключ, публичный ключ и файл с хостами.

ssh-copy-id удобная утилита для добавления открытых ключей на сервера по ssh

![](images/image20.png)

Можно указать пользователя через user@host. Если не указывать юзера будет использовано имя текущего пользователя.

После этого при соединении через ssh на хост будет спрошен пароль.

![](images/image200.png)Можно сделать так, чтобы пароль вводить только один раз в сессии. Для этого

ssh-agent /bin/bash для аллоцирования памяти содержащей пароль

ssh-add для установки пароля

![](images/image224.png)

После этого в текущей сессии не нужно будет вводить пароля при подключении по ssh

/etc/ssh/sshd_config  файл серверных настроек ssh

из важного:

![](images/image213.png) Порт ssh сервера по-умолчанию 22

![](images/image42.png) Узлы с какими ip адресами могут соединяться с сервером по ssh

![](images/image245.png)Возможно зайти под root через ssh. Если сервер открыт всему интернету крайне рекомендуется ставить no.

![](images/image287.png) Список пользователей, под которыми можно заходить по ssh

![](images/image436.png) Возможно ли заходить с паролем. Если выключить будет возможно только по сертификату.

Для применения настроек нужно выполнить.

systemctl restart sshd

/etc/ssh/ssh_config  файл клиентских настроек ssh

Копирование файлов по сети
==========================

Используется сервис sshd

scp file1 file2 user@remoteserver:/home/student  копирование на удаленный сервер

![](images/image59.png)

scp -r user@remoteserver:/home/student .  копирование содержимого директории удаленного сервера в текущую директорию

![](images/image457.png)

![](images/image22.png)

Если логин по сертификату настроен, то и пароля вводить не нужно.

scp user@remoteserver:/etc/hosts /tmp/ копировать файл с удаленного сервера в директорию

или несколько файлов

scp user@server:"file1.txt file2.txt" "~/yourpathtocopy"

Также есть возможно копирование через sftp

sftp user@host Открыть sftp сессию

![](images/image98.png)

lpwd \- отобразить текущую директорию на сервере инициаторе

![](images/image137.png)

pwd \- отобразить текущую директорию на удаленном сервере

![](images/image188.png)

cd &lt;path&gt; сменить директорию на удаленном сервере

![](images/image79.png)

lcd &lt;path&gt; сменить директорию на сервере инициаторе

![](images/image172.png)

get &lt;path&gt; загрузить файл с удаленном сервера

![](images/image118.png)

exit для закрытия sftp сессии

put &lt;path&gt; отправка файла на удаленный сервер

![](images/image9.png)

Rsync Синхронизация директорий по сети
======================================

rsync использует ssh для синхронизации

### опции:

-r синхронизация всей вложенной структуры директорий

-l синхронизация symbolic ссылок

-p не синхронизировать symbolic ссылки

-n (dry-run) не синхронизировать, просто отобразить то, что могло бы быть синхронизировано

-a archive-mode будет синхронизировано почти все. Эквивалент -rlptgoD

-A синзронизация как в -a + синхронизация ACL

-X синхронизация SELinux контекста

Скопируем файлы из /etc в папку на сервере через scp

![](images/image60.png)

![](images/image425.png)

Теперь на удаленном сервере создадим новые файлы в /etc

![](images/image67.png)![](images/image459.png)

Теперь хотим получить изменения в каталоге /etc на первом сервере. Но все файлы копировать не хочется заново, т.к они уже скопированы. Воспользуемся rsync

![](images/image369.png)

При этом копируются только новые файлы.

![](images/image246.png)

HTTP Server
===========

для понимания темы с SELinux нужно рассмотреть настройки сервиса. Рассмотрим httpd он же Apache Server.

/etc/httpd/conf/httpd.conf файл настроек httpd

![](images/image348.png) Порт для сервеа

/etc/httpd/conf.d/ каталог для дополнительных настроек httpd

/var/www/htdocs расположение документации в html формате

![](images/image207.png)

![](images/image153.png)

SELinux
=======

Часть ядра написанная RedHat для усовершенствования инструментов безопасности.

![](images/image218.png)

SELinux может быть в состоянии disabled и enabled. Т.к это состояние указывается на уровне ядра, оно может быть изменено только после перезагрузки. НО в enabled режиме есть два подрежима. Enforsing - все запрещено, что не разрешено явно в правилах SELinux. Permissing - режим для отладки, все разрешено, но осуществляется логирование. Режим Permissing рекомендуется включать только в случае возникновения неполадок, когда непонятно почему правила SELinux не разрешают то или иное действие.

getenforce показать текущий режим SELinux

![](images/image261.png)

setenforce переключить текущий режим SELinux между permissive и enforsing

![](images/image301.png)

![](images/image389.png)

/etc/sysconfig/selinux файл конфигурации SELinux. Также можно задать состояние при старте.

![](images/image314.png)

Рекомендуется никогда не ставить состояние disabled, если предполагается только временное отключение selinux. Лучше идти через permissive mode.

Если все-таки SELinux отключить, то включить его будет возможно только перезагрузки

![](images/image335.png)

Context label
-------------

У каждого обьекта в RHEL имеется context label. Она состоит из:

user (user context)

role (role specific context)

type (признак того, какие операции разрешены с обьектом)

Многие команды через опцию -Z показывают свойства контекста обьекта

Типы используются в правилах безопасности , какой source обьект имеет доступ к target обьекту.

Пример: если добавить к команде ps aux опцию Z , т.е ps auxZ, отобразиться информация о процессах \+ информация от SELinux.

![](images/image76.png)

Видим context label, состояющую из трех частей: u - user  r- role t-type. Важен именно type.

Посмотрим, что дает опция Z вместе с командой ls -ldZ /etc/ssh

![](images/image307.png)

![](images/image230.png)

Сервис sshd имеет доступ к этим файлам только потому, что существуют правило, которое определяет доступ типа sshd к обьектам etc_и к обьектам типа sshd\_key\_

Такой же пример можно привести с httpd

![](images/image177.png)

![](images/image263.png)

Существуют правила доступа типа httpd_ к обьектам типов httpd\_sys\_script\_exec\_ и httpd\_sys\_content_

![](images/image396.png)

Boolean

Также в RHEL есть флаги boolean. Показать флаги getsebool -a

![](images/image235.png)

![](images/image74.png)

Видим флаг httpd\_enable\_homedirs. Чтобы его поменять

sudo setsebool -P httpd\_enable\_homedirs on

![](images/image298.png)

![](images/image84.png)

Изменение context label
-----------------------

semanage fcontext

restorecon Для применения изменений контекста.

Иначе можно создать файл touch /.autorelabel в корневой директории файловой системы и перезагрузить сервер.

Пример:

Укажем для httpd новую корневую папку, из которой необходимо отображать html страницу

![](images/image350.png)

![](images/image214.png)

![](images/image165.png)

![](images/image160.png)

![](images/image227.png)

![](images/image36.png)

Видим, что получить доступ не можем. Посмотрим на режиме SELinux

![](images/image102.png)

Тут нужно подумать, что возможно httpd не может получить доступ к файлу index.html из-за отсутствия правила в selinux. Поменяем режим SELinux на permissive, чтобы проверить эту гипотезу.

![](images/image34.png)

![](images/image354.png)

Да, действительно правила не позволяют получить доступ.

![](images/image387.png)

Видим что тип каталога default.

Добавим поменяем тип

semanage fcontext -a -t httpd\_sys\_content_t “/web(/.*)?”

-a - добавление

-t - тип

![](images/image120.png)

далее применим изменения

restorecon -R -v  /web

![](images/image225.png)

![](images/image294.png)

![](images/image325.png)

Чтение лога SELinux
-------------------

SELinux использует сервис auditd для записи в audit log. Текст в audit log непросто понять.

Есть команда sealert, которая переводит события из audit log в понятный формат и пишет в /var/log/messages

![](images/image142.png)

Выведем события audit.log . Найдем событие связанное с httpd

![](images/image99.png)

указывется source и target context

Также можем вывести что у нас попало в системное логирование

journalctl | grep sealert

![](images/image24.png)

В логе видим подсказку как получить детальную информацию о событии

![](images/image359.png)

![](images/image270.png)

restorecon используется также для восстановления правил SELinux на директории. Например если скопируем какой-то файл в etc, например из home , его тип будет отличаться от файлов находящихся в /etc. restorecon восстановит правило.

Firewalling
===========

![](images/image33.png)

Самые низкоуровневые настройки фаервола на уровне системы доступны в nftables. Ниже только ядро. В ранних версиях RHEL использовались iptables для более понятного конфигурирования правил. Начиная с RHEL 8 используется сервис firewalld

![](images/image69.png)

Зоны используются для создания разных правил в зависимости от типа трафика. Например можно создавать для пакетов приходящих из локальной сети отдельные правила нежели для пакетов приходящих из интернета

firewall-cmd утилита для настройки фаервола. Если используем ключ -permanent настройка сохранится постоянно, НО не примениться сию же секунду для runtime. Если не указываем -permanent применяем настройку в runtime, но не фиксируем навсегда

firewall-cmd --list-all для отображения текущих настроек

![](images/image64.png)

Начинается с зоны. По-умолчанию зона public , также зона имеет статус active. Также видим в interface одна сетевая карта на машине. Также видим сервисы. которым разрешено работать в данной зоне. Видим, что нет специализированных правил для ports

firewall-cmd --get-services Список доступных сервисов

![](images/image267.png)

firewall-cmd --add-service &lt;name&gt; Добавить сервис в фаервол

![](images/image406.png)

![](images/image381.png)

firewall-cmd --reload Обновить правила фаервола

![](images/image302.png)

Видим что после обновления правил, сервис ftp пропал. А все потому, что не применили опцию --permanent

![](images/image292.png)

Существует GUI утилита firewall-config, которую необходимо устанавливать.

![](images/image43.png)

Linux time
==========

![](images/image123.png)

Все начинается с аппаратных часов внутри оборудования. При загрузке система обращается к оборудованию и устанавливает время на уровне операционной системы. Если аппаратные часы в оборудовании не работают у системы будет неверное время. Есть команда hwclock которая позволяет узнавать время аппаратных часов, так и устанавливать их, синхронизировать системные и аппаратные часы.

Также существуют стара команда date для установки системного времени и получения системного времени.

Наиболее современная команда это timedatectl.

![](images/image222.png)

Нередки случаи когда сервера получают время от централизованного NTP сервера.

Через утилиту можно делать многие команды со временем.

![](images/image296.png)

Поменяем временную зону.

Сначала выведем список доступных временных зон.

![](images/image10.png)

Затем установим зону.

![](images/image439.png)

Kickstart
=========

Тулза для автоматической установки RHEL из файла конфигурации. Файл находится в home директории root и называется anaconda-ks.cfg

![](images/image356.png)

Обычно этот файл шарится через http и при установке новой машины, на него указывается ссылка

![](images/image331.png)

![](images/image217.png)

Vagrant
=======

Тулза для развертывания виртуальных машин

![](images/image93.png)

NFS
===

Используется для предоставления доступа к ресурсам по сети \- создание сетевого диска.

Необходимо:

1.  Запустить сервис nfs-service

![](images/image16.png)

2.  Создать директорию, которую хотим шарить. Например /data
3.  Сконфигурировать файл /etc/exports

/data * (rw,no\_root\_squash)

![](images/image339.png)

\* тут означает, что шарим любым ip адресами и dns именам (world wide welcome)

rw значит все будут иметь права на запись. no\_root\_squash если подключаемся с правами root, то будем иметь права в папке

       4)        Прописать 3 сервиса в фаерволе.

![](images/image47.png)

C клиентского сервера проверить доступен ли mount

![](images/image147.png)

Сделаем временный mount на клиенте

![](images/image265.png)

Для постоянного монтирования внесем изменения в /etc/fstab

![](images/image186.png)

Samba
=====

Используется для предоставление доступа к ресурсам, которые поддерживают и Windows файлы

1.  Установим пакет для samba

![](images/image317.png)

2.  Создадим каталог для файлов, которые хотим шарить

![](images/image258.png)

3.  Создадим пользователя для samba

![](images/image23.png)

4.  Установим владельцем созданной папки созданного пользователя

![](images/image415.png)

![](images/image212.png)

5.  Установим пароль для пользователя samba для подключения

![](images/image433.png)

6.  Настроим файл конфигурации /etc/samba/smb.conf

![](images/image51.png)

![](images/image435.png)

7.  Стартуем сервис smb

![](images/image166.png)

8.  Добавить сервис samba в файрвол

![](images/image183.png)

А еще необходимо поставить на папку и файлы в каталоге для расшариривания тип, который будет разрешать SELinux для сервиса samba

![](images/image456.png)

Подключаемся как клиент:

1.  Установить пакеты cifs-utils и samba-client

можно поставить группу пакетов “Network File System Client”

yum group install “Network File System Client”

2.  Проверить какие ресурсы доступны на сервере с самбой

smbclient -L //192.168.100.11

![](images/image216.png)

3.  Проверить монтирование в mnt

mount -o username=samba //192.168.100.11/samba /mnt

ввести пароль от пользователя samba

4.  Для постоянного монтирование укажем в fstab

![](images/image25.png)

Automount
=========

Монтирование ресурсов иногда удобнее организовать через automount, который позволяет включать монтирование только тогда, когда это необходимо.

файл конфигурации /etc/auto.master

файл содержит директории вместе с файлом настройки монтирования для этой директории

![](images/image392.png)

например /data  /etc/auto.data. Тут директория это /data , а в файле auto.data будут настроки чего будет монтировать в директорию.

Например там будет:

![](images/image168.png)

files это директория внутри /data. Далее права на чтение и запись, а дальше что монтируем, в данном случае это nfs сервер

1.  Установим пакет autofs

![](images/image148.png)

2.  Включим сервис

systemctl enable --now autofs

![](images/image192.png)

После включения увидим что в / каталоге появились дополнительные директории, net и misc

![](images/image408.png)

В файле /etc/auto.maset (см. выше) есть строчка с каталогом /misc и с файлом конфигурации для него. Посмотрим в него

![](images/image240.png)

Тут есть примеры того, как можно монтировать через autofs. Поддиректории, далее файловые системы, далее ресурсы.

3.  Создадим записьв /etc/auto.master с новой директорией files. Также укажем новый файл для конфигурации

![](images/image72.png)

![](images/image135.png)

![](images/image360.png)

4.  Рестартуем сервис autofs

![](images/image390.png)

5.  Увидим что создалась директория files

![](images/image251.png)

Но никаких файлов внутри нее нет

![](images/image209.png)

6.  НО если попытаемся войти в директории data , то команда отработает. Т.е монтирование происходит в тот момент. когда происходит обращение к ресурсу.

![](images/image125.png)

Это позволяет не тратить время на монтирование ресурсов, которые в данные момент не нужны, а монтировать их в момент использования

Пример настройки динамического home

В файле /etc/auto.master укажем

![](images/image349.png)

в файле настроек /etc/auto.ldap укажем

![](images/image283.png)

![](images/image427.png)

### Проброс X11

Для того. чтобы сервер рисовал на экране клиента. Нужно сделать следующее.

на сервере:

Для CentOS/RHEL 8

1.  поставить пакеты:  

sudo yum install xorg-x11-server-Xorg xorg-x11-xauth

![](images/image132.png)

для проверки можно поставить и пакет xorg-x11-apps, но в репозитории RHEL его нет. приходится делать так:

![](images/image274.png)

2.  в файле /etc/ssh/sshd_config поставить две строки:

![](images/image159.png)

3.  перезапустить сервис sshd.

systemctl restart sshd

На клиенте:

установить X сервер. Например XMing.

также есть встроенный x сервер в Mobaxterm.

Далее при заходе через ssh указать опцию -Y.

например ssh -Y dima@192.168.0.32

Могут быть трудности. Из Putty при установке в меню опции ![](images/image133.png)

и поднятом x сервере все работает ок.

Из gitbash и из powershell не заводится.

Лечится это установкой переменной окружения DISPLAY=127.0.0.1:0

![](images/image281.png)

![](images/image333.png)

![](images/image288.png)